diff --git a/src/imports/controls/imagine/qquickninepatchimage.cpp b/src/imports/controls/imagine/qquickninepatchimage.cpp
index 712439889..7d5e4f719 100644
--- a/src/imports/controls/imagine/qquickninepatchimage.cpp
+++ b/src/imports/controls/imagine/qquickninepatchimage.cpp
@@ -386,12 +386,7 @@ void QQuickNinePatchImage::pixmapChange()
 {
     Q_D(QQuickNinePatchImage);
     if (QFileInfo(d->url.fileName()).completeSuffix().toLower() == QLatin1String("9.png")) {
-        // Keep resetNode if it is already set, we do not want to miss an
-        // ImageNode->NinePatchNode change.  Without this there's a chance one gets
-        // an incorrect cast on oldNode every once in a while with source changes.
-        if (!d->resetNode)
-            d->resetNode = d->ninePatch.isNull();
-
+        d->resetNode = d->ninePatch.isNull();
         d->ninePatch = d->pix.image();
         if (d->ninePatch.depth() != 32)
             d->ninePatch = d->ninePatch.convertToFormat(QImage::Format_ARGB32);
@@ -454,13 +449,6 @@ QSGNode *QQuickNinePatchImage::updatePaintNode(QSGNode *oldNode, UpdatePaintNode
     qsgnode_set_description(patchNode, QString::fromLatin1("QQuickNinePatchImage: '%1'").arg(d->url.toString()));
 #endif
 
-    // The image may wrap non-owned data (due to pixmapChange). Ensure we never
-    // pass such an image to the scenegraph, because with a separate render
-    // thread the data may become invalid (in a subsequent pixmapChange on the
-    // gui thread) by the time the renderer gets to do something with the QImage
-    // passed in here.
-    image.detach();
-
     QSGTexture *texture = window()->createTextureFromImage(image);
     patchNode->initialize(texture, sz * d->devicePixelRatio, image.size(), d->xDivs, d->yDivs, d->devicePixelRatio);
     return patchNode;
diff --git a/src/quicktemplates2/qquickabstractbutton.cpp b/src/quicktemplates2/qquickabstractbutton.cpp
index 950e4e099..1df0c706d 100644
--- a/src/quicktemplates2/qquickabstractbutton.cpp
+++ b/src/quicktemplates2/qquickabstractbutton.cpp
@@ -387,6 +387,17 @@ void QQuickAbstractButtonPrivate::itemImplicitHeightChanged(QQuickItem *item)
         emit q->implicitIndicatorHeightChanged();
 }
 
+void QQuickAbstractButtonPrivate::itemDestroyed(QQuickItem *item)
+{
+    Q_Q(QQuickAbstractButton);
+    QQuickControlPrivate::itemDestroyed(item);
+    if (item == indicator) {
+        indicator = nullptr;
+        emit q->implicitIndicatorWidthChanged();
+        emit q->implicitIndicatorHeightChanged();
+    }
+}
+
 QQuickAbstractButton *QQuickAbstractButtonPrivate::findCheckedButton() const
 {
     Q_Q(const QQuickAbstractButton);
diff --git a/src/quicktemplates2/qquickabstractbutton_p_p.h b/src/quicktemplates2/qquickabstractbutton_p_p.h
index 9291c1a87..b729720f2 100644
--- a/src/quicktemplates2/qquickabstractbutton_p_p.h
+++ b/src/quicktemplates2/qquickabstractbutton_p_p.h
@@ -109,6 +109,7 @@ public:
 
     void itemImplicitWidthChanged(QQuickItem *item) override;
     void itemImplicitHeightChanged(QQuickItem *item) override;
+    void itemDestroyed(QQuickItem *item) override;
 
     // copied from qabstractbutton.cpp
     static const int AUTO_REPEAT_DELAY = 300;
diff --git a/src/quicktemplates2/qquickaction.cpp b/src/quicktemplates2/qquickaction.cpp
index 2041e7741..8610cdfae 100644
--- a/src/quicktemplates2/qquickaction.cpp
+++ b/src/quicktemplates2/qquickaction.cpp
@@ -145,7 +145,7 @@ int QQuickActionPrivate::ShortcutEntry::shortcutId() const
 
 void QQuickActionPrivate::ShortcutEntry::grab(const QKeySequence &shortcut, bool enabled)
 {
-    if (shortcut.isEmpty())
+    if (shortcut.isEmpty() || m_shortcutId)
         return;
 
     Qt::ShortcutContext context = Qt::WindowShortcut; // TODO
diff --git a/src/quicktemplates2/qquickcombobox.cpp b/src/quicktemplates2/qquickcombobox.cpp
index b715659f1..ea8d3d1d7 100644
--- a/src/quicktemplates2/qquickcombobox.cpp
+++ b/src/quicktemplates2/qquickcombobox.cpp
@@ -1740,11 +1740,7 @@ void QQuickComboBox::focusInEvent(QFocusEvent *event)
 {
     Q_D(QQuickComboBox);
     QQuickControl::focusInEvent(event);
-    // Setting focus on TextField should not be done when drop down indicator was clicked
-    // That is why, if focus is not set with key reason, it should not be passed to textEdit by default.
-    // Focus on Edit Text should be set only intentionally by user.
-    if ((event->reason() == Qt::TabFocusReason || event->reason() == Qt::BacktabFocusReason ||
-            event->reason() == Qt::ShortcutFocusReason) && d->contentItem && isEditable())
+    if (d->contentItem && isEditable())
         d->contentItem->forceActiveFocus(event->reason());
 }
 
diff --git a/src/quicktemplates2/qquickcontainer.cpp b/src/quicktemplates2/qquickcontainer.cpp
index f38c2b09c..6eed2a024 100644
--- a/src/quicktemplates2/qquickcontainer.cpp
+++ b/src/quicktemplates2/qquickcontainer.cpp
@@ -225,6 +225,7 @@ void QQuickContainerPrivate::cleanup()
     QObject::disconnect(contentModel, &QQmlObjectModel::countChanged, q, &QQuickContainer::countChanged);
     QObject::disconnect(contentModel, &QQmlObjectModel::childrenChanged, q, &QQuickContainer::contentChildrenChanged);
     delete contentModel;
+    contentModel = nullptr;
 }
 
 QQuickItem *QQuickContainerPrivate::itemAt(int index) const
@@ -436,7 +437,7 @@ void QQuickContainerPrivate::contentChildren_clear(QQmlListProperty<QQuickItem>
 void QQuickContainerPrivate::updateContentWidth()
 {
     Q_Q(QQuickContainer);
-    if (hasContentWidth || qFuzzyCompare(contentWidth, implicitContentWidth))
+    if (hasContentWidth || qFuzzyCompare(contentWidth, implicitContentWidth) || !contentModel)
         return;
 
     contentWidth = implicitContentWidth;
@@ -446,7 +447,7 @@ void QQuickContainerPrivate::updateContentWidth()
 void QQuickContainerPrivate::updateContentHeight()
 {
     Q_Q(QQuickContainer);
-    if (hasContentHeight || qFuzzyCompare(contentHeight, implicitContentHeight))
+    if (hasContentHeight || qFuzzyCompare(contentHeight, implicitContentHeight) || !contentModel)
         return;
 
     contentHeight = implicitContentHeight;
diff --git a/src/quicktemplates2/qquickdialogbuttonbox.cpp b/src/quicktemplates2/qquickdialogbuttonbox.cpp
index e6db14eb5..6197d1547 100644
--- a/src/quicktemplates2/qquickdialogbuttonbox.cpp
+++ b/src/quicktemplates2/qquickdialogbuttonbox.cpp
@@ -237,7 +237,7 @@ static QRectF alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment
 void QQuickDialogButtonBoxPrivate::resizeContent()
 {
     Q_Q(QQuickDialogButtonBox);
-    if (!contentItem)
+    if (!contentItem || !contentModel)
         return;
 
     QRectF geometry = q->boundingRect().adjusted(q->leftPadding(), q->topPadding(), -q->rightPadding(), -q->bottomPadding());
@@ -322,6 +322,9 @@ void QQuickDialogButtonBoxPrivate::updateLayout()
 qreal QQuickDialogButtonBoxPrivate::getContentWidth() const
 {
     Q_Q(const QQuickDialogButtonBox);
+    if (!contentModel)
+        return 0;
+
     const int count = contentModel->count();
     const qreal totalSpacing = qMax(0, count - 1) * spacing;
     qreal totalWidth = totalSpacing;
@@ -341,6 +344,9 @@ qreal QQuickDialogButtonBoxPrivate::getContentWidth() const
 qreal QQuickDialogButtonBoxPrivate::getContentHeight() const
 {
     Q_Q(const QQuickDialogButtonBox);
+    if (!contentModel)
+        return 0;
+
     const int count = contentModel->count();
     qreal maxHeight = 0;
     for (int i = 0; i < count; ++i) {
diff --git a/src/quicktemplates2/qquickoverlay.cpp b/src/quicktemplates2/qquickoverlay.cpp
index b8d417f29..c8cd142ae 100644
--- a/src/quicktemplates2/qquickoverlay.cpp
+++ b/src/quicktemplates2/qquickoverlay.cpp
@@ -399,8 +399,11 @@ void QQuickOverlay::itemChange(ItemChange change, const ItemChangeData &data)
     Q_D(QQuickOverlay);
     QQuickItem::itemChange(change, data);
 
-    if (change == ItemChildAddedChange || change == ItemChildRemovedChange)
+    if (change == ItemChildAddedChange || change == ItemChildRemovedChange) {
         setVisible(!d->allDrawers.isEmpty() || !childItems().isEmpty());
+        if (data.item->parent() == d->mouseGrabberPopup)
+            d->setMouseGrabberPopup(nullptr);
+    }
 }
 
 void QQuickOverlay::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry)
diff --git a/src/quicktemplates2/qtquicktemplates2global.cpp b/src/quicktemplates2/qtquicktemplates2global.cpp
index 5d7816b41..9b79d60c2 100644
--- a/src/quicktemplates2/qtquicktemplates2global.cpp
+++ b/src/quicktemplates2/qtquicktemplates2global.cpp
@@ -42,7 +42,7 @@
 QT_BEGIN_NAMESPACE
 
 #if QT_CONFIG(accessibility)
-static QAccessibleInterface *qQuickAccessibleFactory(const QString &classname, QObject *object)
+QAccessibleInterface *qQuickAccessibleFactory(const QString &classname, QObject *object)
 {
     if (classname == u"QQuickPage") {
         return new QAccessibleQuickPage(qobject_cast<QQuickPage *>(object));
diff --git a/tests/auto/controls/data/tst_combobox.qml b/tests/auto/controls/data/tst_combobox.qml
index eaf9b3c6c..cd4c8466d 100644
--- a/tests/auto/controls/data/tst_combobox.qml
+++ b/tests/auto/controls/data/tst_combobox.qml
@@ -1547,7 +1547,7 @@ TestCase {
         control.editText = ""
         compare(control.acceptableInput, true)
         control.editText = ""
-        control.contentItem.forceActiveFocus()
+        control.forceActiveFocus()
         keyPress(Qt.Key_A)
         compare(control.editText, "")
         keyPress(Qt.Key_A)
@@ -1584,7 +1584,7 @@ TestCase {
 
         compare(control.currentIndex, 0)
         compare(control.currentText, "first")
-        control.contentItem.forceActiveFocus()
+        control.forceActiveFocus()
         compare(control.activeFocus, true)
 
         control.selectAll()
@@ -1607,7 +1607,7 @@ TestCase {
         var control = createTemporaryObject(comboBox, testCase, {editable: true, model: ["Banana", "Coco", "Coconut", "Apple", "Cocomuffin"]})
         verify(control)
 
-        control.contentItem.forceActiveFocus()
+        control.forceActiveFocus()
         verify(control.activeFocus)
 
         var acceptCount = 0
@@ -1758,7 +1758,7 @@ TestCase {
         var control = createTemporaryObject(keysAttachedBox, testCase)
         verify(control)
 
-        control.contentItem.forceActiveFocus()
+        control.forceActiveFocus()
         verify(control.activeFocus)
 
         verify(!control.gotit)
@@ -2013,7 +2013,7 @@ TestCase {
 
         // Give the first ComboBox focus and type in 0 to select "Item 10" (default is "Item 1").
         waitForRendering(comboBox1)
-        comboBox1.contentItem.forceActiveFocus()
+        comboBox1.forceActiveFocus()
         verify(comboBox1.activeFocus)
         keyClick(Qt.Key_0)
         compare(comboBox1.editText, "Item 10")
@@ -2031,7 +2031,7 @@ TestCase {
 
         // Give focus back to the first ComboBox, and try the same thing except
         // with non-existing text; the currentIndex should not change.
-        comboBox1.contentItem.forceActiveFocus()
+        comboBox1.forceActiveFocus()
         verify(comboBox1.activeFocus)
         keySequence(StandardKey.SelectAll)
         compare(comboBox1.contentItem.selectedText, "Item 10")
@@ -2043,23 +2043,4 @@ TestCase {
         compare(comboBox1.currentIndex, 9)
         compare(currentIndexSpy.count, 1)
     }
-
-    // QTBUG-61021: text line should not be focused by default
-    // It causes (e.g. on Android) showing virtual keyboard when it is not needed
-    function test_doNotFocusTextLineByDefault() {
-        var control = createTemporaryObject(comboBox, testCase)
-        // Focus not set after creating combobox
-        verify(!control.activeFocus)
-        verify(!control.contentItem.focus)
-
-        // After setting focus on combobox, text line should not be focused
-        control.forceActiveFocus()
-        verify(control.activeFocus)
-        verify(!control.contentItem.focus)
-
-        // Text line is focused after intentional setting focus on it
-        control.contentItem.forceActiveFocus()
-        verify(control.activeFocus)
-        verify(control.contentItem.focus)
-    }
 }
diff --git a/tests/auto/controls/data/tst_switch.qml b/tests/auto/controls/data/tst_switch.qml
index b3fab41ca..10b6baa02 100644
--- a/tests/auto/controls/data/tst_switch.qml
+++ b/tests/auto/controls/data/tst_switch.qml
@@ -608,4 +608,27 @@ TestCase {
         mouseClick(control.indicator)
         verify(control.activeFocus)
     }
+
+    Component {
+        id: deletionOrder1
+        Item {
+            Image { id: innerImage }
+            Switch { indicator: innerImage }
+        }
+    }
+
+    Component {
+        id: deletionOrder2
+        Item {
+            Switch { indicator: innerImage }
+            Image { id: innerImage }
+        }
+    }
+
+    function test_deletionOrder() {
+        var control1 = createTemporaryObject(deletionOrder1, testCase)
+        verify(control1)
+        var control2 = createTemporaryObject(deletionOrder2, testCase)
+        verify(control2)
+    }
 }
diff --git a/tests/auto/qquickpopup/data/releaseAfterExitTransition.qml b/tests/auto/qquickpopup/data/releaseAfterExitTransition.qml
new file mode 100644
index 000000000..9e4598b9f
--- /dev/null
+++ b/tests/auto/qquickpopup/data/releaseAfterExitTransition.qml
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** BSD License Usage
+** Alternatively, you may use this file under the terms of the BSD license
+** as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of The Qt Company Ltd nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.15
+import QtQuick.Controls 2.15
+
+ApplicationWindow {
+    id: window
+    width: 400
+    height: 400
+    title: "releaseAfterExitTransition"
+
+    property alias popup: popup
+    property alias modalPopup: modalPopup
+
+    Popup {
+        id: popup
+        y: parent.height - height
+        width: 50
+        height: 50
+    }
+
+    Popup {
+        id: modalPopup
+        modal: true
+        y: parent.height - height
+        width: 50
+        height: 50
+        exit:  Transition { PauseAnimation { duration: 100 } }
+    }
+}
diff --git a/tests/auto/qquickpopup/tst_qquickpopup.cpp b/tests/auto/qquickpopup/tst_qquickpopup.cpp
index ede3640c2..f1840946b 100644
--- a/tests/auto/qquickpopup/tst_qquickpopup.cpp
+++ b/tests/auto/qquickpopup/tst_qquickpopup.cpp
@@ -97,6 +97,7 @@ private slots:
     void invisibleToolTipOpen();
     void centerInOverlayWithinStackViewItem();
     void destroyDuringExitTransition();
+    void releaseAfterExitTransition();
 };
 
 void tst_QQuickPopup::initTestCase()
@@ -1459,6 +1460,34 @@ void tst_QQuickPopup::destroyDuringExitTransition()
     QVERIFY(!button->isDown());
 }
 
+void tst_QQuickPopup::releaseAfterExitTransition()
+{
+    QQuickApplicationHelper helper(this, "releaseAfterExitTransition.qml");
+    QVERIFY2(helper.ready, helper.failureMessage());
+
+    QQuickWindow *window = helper.window;
+    window->show();
+    QVERIFY(QTest::qWaitForWindowActive(window));
+
+    QQuickOverlay *overlay = QQuickOverlay::overlay(window);
+    QQuickPopup *modalPopup = window->property("modalPopup").value<QQuickPopup *>();
+    QQuickPopup *popup = window->property("popup").value<QQuickPopup *>();
+
+    modalPopup->open();
+    QTRY_VERIFY(modalPopup->isOpened());
+
+    QTest::mousePress(window, Qt::LeftButton, Qt::NoModifier, QPoint(1, 1));
+    // wait until the transition is finished and the overlay hides itself
+    QTRY_VERIFY(!overlay->isVisible());
+    QTest::mouseRelease(window, Qt::LeftButton, Qt::NoModifier, QPoint(1, 1));
+
+    popup->open();
+    QTRY_VERIFY(popup->isOpened());
+    QTest::mouseClick(window, Qt::LeftButton, Qt::NoModifier, QPoint(1, 1));
+    QTRY_VERIFY(!popup->isOpened());
+}
+
+
 QTEST_QUICKCONTROLS_MAIN(tst_QQuickPopup)
 
 #include "tst_qquickpopup.moc"
