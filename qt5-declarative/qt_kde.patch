diff --git a/src/3rdparty/masm/yarr/Yarr.h b/src/3rdparty/masm/yarr/Yarr.h
index ccf78f9880..2955ea7e72 100644
--- a/src/3rdparty/masm/yarr/Yarr.h
+++ b/src/3rdparty/masm/yarr/Yarr.h
@@ -28,6 +28,7 @@
 #pragma once
 
 #include <limits.h>
+#include <limits>
 #include "YarrErrorCode.h"
 
 namespace JSC { namespace Yarr {
diff --git a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileengine.cpp b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileengine.cpp
index e11b8c9776..5e78539155 100644
--- a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileengine.cpp
+++ b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileengine.cpp
@@ -398,14 +398,6 @@ bool QQmlPreviewFileEngine::supportsExtension(Extension extension) const
 
 void QQmlPreviewFileEngine::load() const
 {
-    // We can get here from different threads on different instances of QQmlPreviewFileEngine.
-    // However, there is only one loader per QQmlPreviewFileEngineHandler and it is not thread-safe.
-    // Its content mutex doesn't help us here because we explicitly wait on it in load(), which
-    // causes it to be released. Therefore, lock the load mutex first.
-    // This doesn't cause any deadlocks because the only thread that wakes the loader on the content
-    // mutex never calls load(). It's the QML debug server thread that handles the debug protocol.
-    QMutexLocker loadLocker(m_loader->loadMutex());
-
     m_result = m_loader->load(m_absolute);
     switch (m_result) {
     case QQmlPreviewFileLoader::File:
diff --git a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.cpp b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.cpp
index 8d8a8f18d2..bb43f75c63 100644
--- a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.cpp
+++ b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.cpp
@@ -101,7 +101,7 @@ QQmlPreviewFileLoader::~QQmlPreviewFileLoader() {
 
 QQmlPreviewFileLoader::Result QQmlPreviewFileLoader::load(const QString &path)
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     m_path = path;
 
     auto fileIterator = m_fileCache.constFind(path);
@@ -124,19 +124,19 @@ QQmlPreviewFileLoader::Result QQmlPreviewFileLoader::load(const QString &path)
     m_entries.clear();
     m_contents.clear();
     emit request(path);
-    m_waitCondition.wait(&m_contentMutex);
+    m_waitCondition.wait(&m_mutex);
     return m_result;
 }
 
 QByteArray QQmlPreviewFileLoader::contents()
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     return m_contents;
 }
 
 QStringList QQmlPreviewFileLoader::entries()
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     return m_entries;
 }
 
@@ -144,20 +144,20 @@ void QQmlPreviewFileLoader::whitelist(const QUrl &url)
 {
     const QString path = QQmlFile::urlToLocalFileOrQrc(url);
     if (!path.isEmpty()) {
-        QMutexLocker locker(&m_contentMutex);
+        QMutexLocker locker(&m_mutex);
         m_blacklist.whitelist(path);
     }
 }
 
 bool QQmlPreviewFileLoader::isBlacklisted(const QString &path)
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     return m_blacklist.isBlacklisted(path);
 }
 
 void QQmlPreviewFileLoader::file(const QString &path, const QByteArray &contents)
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     m_blacklist.whitelist(path);
     m_fileCache[path] = contents;
     if (path == m_path) {
@@ -169,7 +169,7 @@ void QQmlPreviewFileLoader::file(const QString &path, const QByteArray &contents
 
 void QQmlPreviewFileLoader::directory(const QString &path, const QStringList &entries)
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     m_blacklist.whitelist(path);
     m_directoryCache[path] = entries;
     if (path == m_path) {
@@ -181,7 +181,7 @@ void QQmlPreviewFileLoader::directory(const QString &path, const QStringList &en
 
 void QQmlPreviewFileLoader::error(const QString &path)
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     m_blacklist.blacklist(path);
     if (path == m_path) {
         m_result = Fallback;
@@ -191,7 +191,7 @@ void QQmlPreviewFileLoader::error(const QString &path)
 
 void QQmlPreviewFileLoader::clearCache()
 {
-    QMutexLocker locker(&m_contentMutex);
+    QMutexLocker locker(&m_mutex);
     m_fileCache.clear();
     m_directoryCache.clear();
 }
diff --git a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.h b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.h
index ffda9c0dbf..0c55c48c4a 100644
--- a/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.h
+++ b/src/plugins/qmltooling/qmldbg_preview/qqmlpreviewfileloader.h
@@ -79,9 +79,7 @@ public:
     QQmlPreviewFileLoader(QQmlPreviewServiceImpl *service);
     ~QQmlPreviewFileLoader();
 
-    QMutex *loadMutex() { return &m_loadMutex; }
     Result load(const QString &file);
-
     QByteArray contents();
     QStringList entries();
 
@@ -92,8 +90,7 @@ signals:
     void request(const QString &file);
 
 private:
-    QMutex m_loadMutex;
-    QMutex m_contentMutex;
+    QMutex m_mutex;
     QWaitCondition m_waitCondition;
 
     QThread m_thread;
diff --git a/src/qml/common/qqmljsfixedpoolarray_p.h b/src/qml/common/qqmljsfixedpoolarray_p.h
index b65b994d6c..15a8cd6878 100644
--- a/src/qml/common/qqmljsfixedpoolarray_p.h
+++ b/src/qml/common/qqmljsfixedpoolarray_p.h
@@ -86,7 +86,7 @@ public:
         if (QTypeInfo<T>::isComplex) {
             for (int i = 0; i < count; ++i)
                 new (data + i) T(vector.at(i));
-        } else {
+        } else if (count) {
             memcpy(data, static_cast<const void*>(vector.constData()), count * sizeof(T));
         }
     }
diff --git a/src/qml/jsruntime/qv4dateobject.cpp b/src/qml/jsruntime/qv4dateobject.cpp
index a14c7d9257..4e445a73fa 100644
--- a/src/qml/jsruntime/qv4dateobject.cpp
+++ b/src/qml/jsruntime/qv4dateobject.cpp
@@ -78,21 +78,10 @@
   QTBUG-75585 for an explanation and possible workarounds.
  */
 #define USE_QTZ_SYSTEM_ZONE
-#elif defined(Q_OS_WASM)
-/*
-    TODO: evaluate using this version of the code more generally, rather than
-    the #else branches of the various USE_QTZ_SYSTEM_ZONE choices. It might even
-    work better than the timezone variant; experiments needed.
-*/
-// Kludge around the lack of time-zone info using QDateTime.
-// It uses localtime() and friends to determine offsets from UTC.
-#define USE_QDT_LOCAL_TIME
 #endif
 
 #ifdef USE_QTZ_SYSTEM_ZONE
 #include <QtCore/QTimeZone>
-#elif defined(USE_QDT_LOCAL_TIME)
-// QDateTime already included above
 #else
 #  ifdef Q_OS_WIN
 #    include <windows.h>
@@ -367,7 +356,6 @@ static inline double MakeDate(double day, double time)
   mean a whole day of DST offset for some zones, that have crossed the
   international date line.  This shall confuse client code.)  The bug report
   against the ECMAScript spec is https://github.com/tc39/ecma262/issues/725
-  and they've now changed the spec so that the following conforms to it ;^>
 */
 
 static inline double DaylightSavingTA(double t, double localTZA) // t is a UTC time
@@ -375,12 +363,6 @@ static inline double DaylightSavingTA(double t, double localTZA) // t is a UTC t
     return QTimeZone::systemTimeZone().offsetFromUtc(
         QDateTime::fromMSecsSinceEpoch(qint64(t), Qt::UTC)) * 1e3 - localTZA;
 }
-#elif defined(USE_QDT_LOCAL_TIME)
-static inline double DaylightSavingTA(double t, double localTZA) // t is a UTC time
-{
-    return QDateTime::fromMSecsSinceEpoch(qint64(t), Qt::UTC
-        ).toLocalTime().offsetFromUtc() * 1e3 - localTZA;
-}
 #else
 // This implementation fails to take account of past changes in standard offset.
 static inline double DaylightSavingTA(double t, double /*localTZA*/)
@@ -739,26 +721,6 @@ static double getLocalTZA()
     // TODO: QTimeZone::resetSystemTimeZone(), see QTBUG-56899 and comment above.
     // Standard offset, with no daylight-savings adjustment, in ms:
     return QTimeZone::systemTimeZone().standardTimeOffset(QDateTime::currentDateTime()) * 1e3;
-#elif defined(USE_QDT_LOCAL_TIME)
-    QDate today = QDate::currentDate();
-    QDateTime near = today.startOfDay(Qt::LocalTime);
-    // Early out if we're in standard time anyway:
-    if (!near.isDaylightTime())
-        return near.offsetFromUtc() * 1000;
-    int year, month;
-    today.getDate(&year, &month, nullptr);
-    // One of the solstices is probably in standard time:
-    QDate summer(year, 6, 21), winter(year - (month < 7 ? 1 : 0), 12, 21);
-    // But check the one closest to the present by preference, in case there's a
-    // standard time offset change between them:
-    QDateTime far = summer.startOfDay(Qt::LocalTime);
-    near = winter.startOfDay(Qt::LocalTime);
-    if (month > 3 && month < 10)
-        near.swap(far);
-    bool isDst = near.isDaylightTime();
-    if (isDst && far.isDaylightTime()) // Permanent DST, probably an hour west:
-        return (qMin(near.offsetFromUtc(), far.offsetFromUtc()) - 3600) * 1000;
-    return (isDst ? far : near).offsetFromUtc() * 1000;
 #else
 #  ifdef Q_OS_WIN
     TIME_ZONE_INFORMATION tzInfo;
diff --git a/src/qml/jsruntime/qv4generatorobject_p.h b/src/qml/jsruntime/qv4generatorobject_p.h
index 14368f5416..10eea5e46b 100644
--- a/src/qml/jsruntime/qv4generatorobject_p.h
+++ b/src/qml/jsruntime/qv4generatorobject_p.h
@@ -87,6 +87,7 @@ struct GeneratorPrototype : FunctionObject {
 
 #define GeneratorObjectMembers(class, Member) \
     Member(class, Pointer, ExecutionContext *, context) \
+    Member(class, Pointer, GeneratorFunction *, function) \
     Member(class, NoMark, GeneratorState, state) \
     Member(class, NoMark, CppStackFrame, cppFrame) \
     Member(class, Pointer, ArrayObject *, values) \
diff --git a/src/qml/jsruntime/qv4qobjectwrapper.cpp b/src/qml/jsruntime/qv4qobjectwrapper.cpp
index 9899c9274e..272b85069f 100644
--- a/src/qml/jsruntime/qv4qobjectwrapper.cpp
+++ b/src/qml/jsruntime/qv4qobjectwrapper.cpp
@@ -1160,8 +1160,7 @@ void Heap::QObjectWrapper::markObjects(Heap::Base *that, QV4::MarkStack *markSta
 void QObjectWrapper::destroyObject(bool lastCall)
 {
     Heap::QObjectWrapper *h = d();
-    if (!h->internalClass)
-        return; // destroyObject already got called
+    Q_ASSERT(h->internalClass);
 
     if (h->object()) {
         QQmlData *ddata = QQmlData::get(h->object(), false);
@@ -1191,7 +1190,7 @@ void QObjectWrapper::destroyObject(bool lastCall)
         }
     }
 
-    h->~Data();
+    h->destroy();
 }
 
 
diff --git a/src/qml/jsruntime/qv4sequenceobject.cpp b/src/qml/jsruntime/qv4sequenceobject.cpp
index f84718b48f..aff8844bb0 100644
--- a/src/qml/jsruntime/qv4sequenceobject.cpp
+++ b/src/qml/jsruntime/qv4sequenceobject.cpp
@@ -720,20 +720,13 @@ DEFINE_OBJECT_TEMPLATE_VTABLE(QQmlRealList);
 }
 
 #define REGISTER_QML_SEQUENCE_METATYPE(unused, unused2, SequenceType, unused3) qRegisterMetaType<SequenceType>(#SequenceType);
-static bool registerAllSequenceTypes()
-{
-    FOREACH_QML_SEQUENCE_TYPE(REGISTER_QML_SEQUENCE_METATYPE)
-    return true;
-}
-#undef REGISTER_QML_SEQUENCE_METATYPE
-
 void SequencePrototype::init()
 {
-    static const bool registered = registerAllSequenceTypes();
-    Q_UNUSED(registered);
+    FOREACH_QML_SEQUENCE_TYPE(REGISTER_QML_SEQUENCE_METATYPE)
     defineDefaultProperty(QStringLiteral("sort"), method_sort, 1);
     defineDefaultProperty(engine()->id_valueOf(), method_valueOf, 0);
 }
+#undef REGISTER_QML_SEQUENCE_METATYPE
 
 ReturnedValue SequencePrototype::method_valueOf(const FunctionObject *f, const Value *thisObject, const Value *, int)
 {
diff --git a/src/qml/memory/qv4mm.cpp b/src/qml/memory/qv4mm.cpp
index 06caf04e5a..da149a67c4 100644
--- a/src/qml/memory/qv4mm.cpp
+++ b/src/qml/memory/qv4mm.cpp
@@ -981,7 +981,7 @@ void MemoryManager::sweep(bool lastSweep, ClassDestroyStatsCallback classCountPt
 
     if (MultiplyWrappedQObjectMap *multiplyWrappedQObjects = engine->m_multiplyWrappedQObjects) {
         for (MultiplyWrappedQObjectMap::Iterator it = multiplyWrappedQObjects->begin(); it != multiplyWrappedQObjects->end();) {
-            if (!it.value().isNullOrUndefined())
+            if (it.value().isNullOrUndefined())
                 it = multiplyWrappedQObjects->erase(it);
             else
                 ++it;
diff --git a/src/qml/qml/qqmlbinding.cpp b/src/qml/qml/qqmlbinding.cpp
index 194f7b4cf7..b9566d5862 100644
--- a/src/qml/qml/qqmlbinding.cpp
+++ b/src/qml/qml/qqmlbinding.cpp
@@ -645,10 +645,7 @@ void QQmlBinding::getPropertyData(QQmlPropertyData **propertyData, QQmlPropertyD
         Q_ASSERT(valueTypeMetaObject);
         QMetaProperty vtProp = valueTypeMetaObject->property(m_targetIndex.valueTypeIndex());
         valueTypeData->setFlags(QQmlPropertyData::flagsForProperty(vtProp));
-
-        // valueTypeData is expected to be local here. It must not be shared with other threads.
         valueTypeData->setPropType(vtProp.userType());
-
         valueTypeData->setCoreIndex(m_targetIndex.valueTypeIndex());
     }
 }
@@ -751,11 +748,7 @@ QQmlBinding *QQmlBinding::newBinding(QQmlEnginePrivate *engine, const QQmlProper
     if (property && property->isQObject())
         return new QObjectPointerBinding(engine, property->propType());
 
-    // If the property is not resolved at this point, you get a binding of unknown type.
-    // This has been the case for a long time and we keep it like this in Qt5 to be bug-compatible.
-    const int type = (property && property->isResolved())
-            ? property->propType()
-            : QMetaType::UnknownType;
+    const int type = (property && property->isFullyResolved()) ? property->propType() : QMetaType::UnknownType;
 
     if (type == qMetaTypeId<QQmlBinding *>()) {
         return new QQmlBindingBinding;
diff --git a/src/qml/qml/qqmlmetaobject.cpp b/src/qml/qml/qqmlmetaobject.cpp
index d273849ccb..a967f46b12 100644
--- a/src/qml/qml/qqmlmetaobject.cpp
+++ b/src/qml/qml/qqmlmetaobject.cpp
@@ -232,6 +232,8 @@ int *QQmlMetaObject::methodParameterTypes(int index, ArgTypeStorage *argStorage,
     Q_ASSERT(!_m.isNull() && index >= 0);
 
     if (_m.isT1()) {
+        typedef QQmlPropertyCacheMethodArguments A;
+
         QQmlPropertyCache *c = _m.asT1();
         Q_ASSERT(index < c->methodIndexCacheStart + c->methodIndexCache.count());
 
@@ -240,16 +242,19 @@ int *QQmlMetaObject::methodParameterTypes(int index, ArgTypeStorage *argStorage,
 
         QQmlPropertyData *rv = const_cast<QQmlPropertyData *>(&c->methodIndexCache.at(index - c->methodIndexCacheStart));
 
-        if (QQmlPropertyCacheMethodArguments *args = rv->arguments())
-            return args->arguments;
+        if (rv->arguments() && static_cast<A *>(rv->arguments())->argumentsValid)
+            return static_cast<A *>(rv->arguments())->arguments;
 
         const QMetaObject *metaObject = c->createMetaObject();
         Q_ASSERT(metaObject);
         QMetaMethod m = metaObject->method(index);
 
         int argc = m.parameterCount();
-
-        QQmlPropertyCacheMethodArguments *args = c->createArgumentsObject(argc, m.parameterNames());
+        if (!rv->arguments()) {
+            A *args = c->createArgumentsObject(argc, m.parameterNames());
+            rv->setArguments(args);
+        }
+        A *args = static_cast<A *>(rv->arguments());
 
         QList<QByteArray> argTypeNames; // Only loaded if needed
 
@@ -275,14 +280,8 @@ int *QQmlMetaObject::methodParameterTypes(int index, ArgTypeStorage *argStorage,
             }
             args->arguments[ii + 1] = type;
         }
-
-        // If we cannot set it, then another thread has set it in the mean time.
-        // Just return that one, then. We don't have to delete the arguments object
-        // we've created as it's tracked in a linked list.
-        if (rv->setArguments(args))
-            return args->arguments;
-        else
-            return rv->arguments()->arguments;
+        args->argumentsValid = true;
+        return static_cast<A *>(rv->arguments())->arguments;
 
     } else {
         QMetaMethod m = _m.asT2()->method(index);
diff --git a/src/qml/qml/qqmlpropertycache.cpp b/src/qml/qml/qqmlpropertycache.cpp
index 6b68a2a288..0911c06cd0 100644
--- a/src/qml/qml/qqmlpropertycache.cpp
+++ b/src/qml/qml/qqmlpropertycache.cpp
@@ -138,17 +138,17 @@ void QQmlPropertyData::lazyLoad(const QMetaProperty &p)
 {
     populate(this, p);
     int type = static_cast<int>(p.userType());
-
-    if (type >= QMetaType::User || type == 0)
-        return; // Resolve later
-
-    if (type == QMetaType::QObjectStar)
+    if (type == QMetaType::QObjectStar) {
+        setPropType(type);
         m_flags.type = Flags::QObjectDerivedType;
-    else if (type == QMetaType::QVariant)
+    } else if (type == QMetaType::QVariant) {
+        setPropType(type);
         m_flags.type = Flags::QVariantType;
-
-    // This is OK because lazyLoad is done before exposing the property data.
-    setPropType(type);
+    } else if (type >= QMetaType::User || type == 0) {
+        m_flags.notFullyResolved = true;
+    } else {
+        setPropType(type);
+    }
 }
 
 void QQmlPropertyData::load(const QMetaProperty &p)
@@ -158,48 +158,45 @@ void QQmlPropertyData::load(const QMetaProperty &p)
     flagsForPropertyType(propType(), m_flags);
 }
 
-static void populate(QQmlPropertyData *data, const QMetaMethod &m)
+void QQmlPropertyData::load(const QMetaMethod &m)
 {
-    data->setCoreIndex(m.methodIndex());
+    setCoreIndex(m.methodIndex());
+    setArguments(nullptr);
 
-    QQmlPropertyData::Flags flags = data->flags();
-    flags.type = QQmlPropertyData::Flags::FunctionType;
-    if (m.methodType() == QMetaMethod::Signal)
-        flags.setIsSignal(true);
-    else if (m.methodType() == QMetaMethod::Constructor)
-        flags.setIsConstructor(true);
+    setPropType(m.returnType());
+
+    m_flags.type = Flags::FunctionType;
+    if (m.methodType() == QMetaMethod::Signal) {
+        m_flags.setIsSignal(true);
+    } else if (m.methodType() == QMetaMethod::Constructor) {
+        m_flags.setIsConstructor(true);
+        setPropType(QMetaType::QObjectStar);
+    }
 
     const int paramCount = m.parameterCount();
     if (paramCount) {
-        flags.setHasArguments(true);
+        m_flags.setHasArguments(true);
         if ((paramCount == 1) && (m.parameterTypes().constFirst() == "QQmlV4Function*"))
-            flags.setIsV4Function(true);
+            m_flags.setIsV4Function(true);
     }
 
     if (m.attributes() & QMetaMethod::Cloned)
-        flags.setIsCloned(true);
-
-    data->setFlags(flags);
+        m_flags.setIsCloned(true);
 
     Q_ASSERT(m.revision() <= Q_INT16_MAX);
-    data->setRevision(m.revision());
-}
-
-void QQmlPropertyData::load(const QMetaMethod &m)
-{
-    populate(this, m);
-    setPropType(m.methodType() == QMetaMethod::Constructor
-                    ? QMetaType::QObjectStar
-                    : m.returnType());
+    setRevision(m.revision());
 }
 
 void QQmlPropertyData::lazyLoad(const QMetaMethod &m)
 {
+    load(m);
+
     const char *returnType = m.typeName();
-    if (!returnType || *returnType != 'v' || qstrcmp(returnType + 1, "oid") != 0)
-        populate(this, m);
-    else
-        load(m); // If it's void, resolve it right away
+    if (!returnType)
+        returnType = "\0";
+    if ((*returnType != 'v') || (qstrcmp(returnType+1, "oid") != 0)) {
+        m_flags.notFullyResolved = true;
+    }
 }
 
 /*!
@@ -321,6 +318,7 @@ void QQmlPropertyCache::appendSignal(const QString &name, QQmlPropertyData::Flag
     data.setPropType(QMetaType::UnknownType);
     data.setCoreIndex(coreIndex);
     data.setFlags(flags);
+    data.setArguments(nullptr);
 
     QQmlPropertyData handler = data;
     handler.m_flags.setIsSignalHandler(true);
@@ -329,6 +327,7 @@ void QQmlPropertyCache::appendSignal(const QString &name, QQmlPropertyData::Flag
         int argumentCount = *types;
         QQmlPropertyCacheMethodArguments *args = createArgumentsObject(argumentCount, names);
         ::memcpy(args->arguments, types, (argumentCount + 1) * sizeof(int));
+        args->argumentsValid = true;
         data.setArguments(args);
     }
 
@@ -362,6 +361,7 @@ void QQmlPropertyCache::appendMethod(const QString &name, QQmlPropertyData::Flag
     QQmlPropertyCacheMethodArguments *args = createArgumentsObject(argumentCount, names);
     for (int ii = 0; ii < argumentCount; ++ii)
         args->arguments[ii + 1] = parameterTypes.at(ii);
+    args->argumentsValid = true;
     data.setArguments(args);
 
     data.setFlags(flags);
@@ -650,23 +650,25 @@ void QQmlPropertyCache::append(const QMetaObject *metaObject,
     }
 }
 
-int QQmlPropertyCache::findPropType(const QQmlPropertyData *data) const
+void QQmlPropertyCache::resolve(QQmlPropertyData *data) const
 {
-    int type = QMetaType::UnknownType;
+    Q_ASSERT(data->notFullyResolved());
+    data->m_flags.notFullyResolved = false;
+
     const QMetaObject *mo = firstCppMetaObject();
     if (data->isFunction()) {
         auto metaMethod = mo->method(data->coreIndex());
         const char *retTy = metaMethod.typeName();
         if (!retTy)
             retTy = "\0";
-        type = QMetaType::type(retTy);
+        data->setPropType(QMetaType::type(retTy));
     } else {
         auto metaProperty = mo->property(data->coreIndex());
-        type = QMetaType::type(metaProperty.typeName());
+        data->setPropType(QMetaType::type(metaProperty.typeName()));
     }
 
     if (!data->isFunction()) {
-        if (type == QMetaType::UnknownType) {
+        if (data->propType() == QMetaType::UnknownType) {
             QQmlPropertyCache *p = _parent;
             while (p && (!mo || _ownMetaObject)) {
                 mo = p->_metaObject;
@@ -682,33 +684,11 @@ int QQmlPropertyCache::findPropType(const QQmlPropertyData *data) const
 
                 int registerResult = -1;
                 void *argv[] = { &registerResult };
-                mo->static_metacall(QMetaObject::RegisterPropertyMetaType,
-                                    data->coreIndex() - propOffset, argv);
-                type = registerResult == -1 ? QMetaType::UnknownType : registerResult;
+                mo->static_metacall(QMetaObject::RegisterPropertyMetaType, data->coreIndex() - propOffset, argv);
+                data->setPropType(registerResult == -1 ? QMetaType::UnknownType : registerResult);
             }
         }
-    }
-
-    return type;
-}
-
-void QQmlPropertyCache::resolve(QQmlPropertyData *data) const
-{
-    const int type = findPropType(data);
-
-    // Setting the flags unsynchronized is somewhat dirty but unlikely to cause trouble
-    // in practice. We have to do this before setting the property type because otherwise
-    // a consumer of the flags might see outdated flags even after the property type has
-    // become valid. The flags should only depend on the property type and the property
-    // type should be the same across different invocations. So, setting this concurrently
-    // should be a noop.
-    if (!data->isFunction())
-        flagsForPropertyType(type, data->m_flags);
-
-    // This is the one place where we can update the property type after exposing the data.
-    if (!data->m_propTypeAndRelativePropIndex.testAndSetOrdered(
-                0, type > 0 ? quint32(type) : quint32(QQmlPropertyData::PropTypeUnknown))) {
-        return; // Someone else is resolving it already
+        flagsForPropertyType(data->propType(), data->m_flags);
     }
 }
 
@@ -893,11 +873,12 @@ QQmlPropertyCacheMethodArguments *QQmlPropertyCache::createArgumentsObject(int a
     typedef QQmlPropertyCacheMethodArguments A;
     A *args = static_cast<A *>(malloc(sizeof(A) + (argc) * sizeof(int)));
     args->arguments[0] = argc;
+    args->argumentsValid = false;
     args->signalParameterStringForJS = nullptr;
+    args->parameterError = false;
     args->names = argc ? new QList<QByteArray>(names) : nullptr;
-    do {
-        args->next = argumentsCache;
-    } while (!argumentsCache.testAndSetRelease(args->next, args));
+    args->next = argumentsCache;
+    argumentsCache = args;
     return args;
 }
 
@@ -1191,6 +1172,7 @@ void QQmlPropertyCache::toMetaObjectBuilder(QMetaObjectBuilder &builder)
         QQmlPropertyCacheMethodArguments *arguments = nullptr;
         if (data->hasArguments()) {
             arguments = (QQmlPropertyCacheMethodArguments *)data->arguments();
+            Q_ASSERT(arguments->argumentsValid);
             for (int ii = 0; ii < arguments->arguments[0]; ++ii) {
                 if (ii != 0) signature.append(',');
                 signature.append(QMetaType::typeName(arguments->arguments[1 + ii]));
diff --git a/src/qml/qml/qqmlpropertycache_p.h b/src/qml/qml/qqmlpropertycache_p.h
index 1563bc0a41..a5340cec37 100644
--- a/src/qml/qml/qqmlpropertycache_p.h
+++ b/src/qml/qml/qqmlpropertycache_p.h
@@ -220,8 +220,6 @@ private:
         _hasPropertyOverrides |= isOverride;
     }
 
-    int findPropType(const QQmlPropertyData *data) const;
-
 private:
     QQmlPropertyCache *_parent;
     int propertyIndexCacheStart;
@@ -241,18 +239,14 @@ private:
     QByteArray _dynamicClassName;
     QByteArray _dynamicStringData;
     QString _defaultPropertyName;
-    QAtomicPointer<QQmlPropertyCacheMethodArguments> argumentsCache;
+    QQmlPropertyCacheMethodArguments *argumentsCache;
     int _jsFactoryMethodIndex;
     QByteArray _checksum;
 };
 
 inline QQmlPropertyData *QQmlPropertyCache::ensureResolved(QQmlPropertyData *p) const
 {
-    // Avoid resolve() in the common case where it's already initialized and we don't
-    // run into a data race. resolve() checks again, with an atomic operation.
-    // If there is no coreIndex, there is no point in trying to resolve anything. In that
-    // case it's a default-constructed instance that never got load()'ed or lazyLoad()'ed.
-    if (p && p->coreIndex() != -1 && Q_UNLIKELY(p->m_propTypeAndRelativePropIndex == 0))
+    if (p && Q_UNLIKELY(p->notFullyResolved()))
         resolve(p);
 
     return p;
diff --git a/src/qml/qml/qqmlpropertycachecreator_p.h b/src/qml/qml/qqmlpropertycachecreator_p.h
index 3fd6c8b4da..77e3763a49 100644
--- a/src/qml/qml/qqmlpropertycachecreator_p.h
+++ b/src/qml/qml/qqmlpropertycachecreator_p.h
@@ -865,10 +865,6 @@ inline QQmlError QQmlPropertyCacheAliasCreator<ObjectContainer>::propertyDataFor
             Q_ASSERT(targetCache);
             targetProperty = targetCache->property(valueTypeIndex);
 
-            if (targetProperty == nullptr) {
-                return qQmlCompileError(alias.referenceLocation,
-                                        QQmlPropertyCacheCreatorBase::tr("Invalid alias target"));
-            }
 
             *type = targetProperty->propType();
             writable = targetProperty->isWritable();
diff --git a/src/qml/qml/qqmlpropertycachemethodarguments_p.h b/src/qml/qml/qqmlpropertycachemethodarguments_p.h
index 32affe6d9c..62f09bdfff 100644
--- a/src/qml/qml/qqmlpropertycachemethodarguments_p.h
+++ b/src/qml/qml/qqmlpropertycachemethodarguments_p.h
@@ -64,6 +64,8 @@ public:
 
     //for signal handler rewrites
     QString *signalParameterStringForJS;
+    int parameterError:1;
+    int argumentsValid:1;
 
     QList<QByteArray> *names;
 
diff --git a/src/qml/qml/qqmlpropertydata_p.h b/src/qml/qml/qqmlpropertydata_p.h
index 2f1b6f62f1..d9855797cd 100644
--- a/src/qml/qml/qqmlpropertydata_p.h
+++ b/src/qml/qml/qqmlpropertydata_p.h
@@ -84,6 +84,14 @@ public:
             QVariantType         = 9  // Property is a QVariant
         };
 
+        // The _otherBits (which "pad" the Flags struct to align it nicely) are used
+        // to store the relative property index. It will only get used when said index fits. See
+        // trySetStaticMetaCallFunction for details.
+        // (Note: this padding is done here, because certain compilers have surprising behavior
+        // when an enum is declared in-between two bit fields.)
+        enum { BitsLeftInFlags = 15 };
+        unsigned otherBits       : BitsLeftInFlags; // align to 32 bits
+
         // Members of the form aORb can only be a when type is not FunctionType, and only be
         // b when type equals FunctionType. For that reason, the semantic meaning of the bit is
         // overloaded, and the accessor functions are used to get the correct value
@@ -94,24 +102,25 @@ public:
         //
         // Lastly, isDirect and isOverridden apply to both functions and non-functions
     private:
-        quint16 isConstantORisVMEFunction   : 1; // Has CONST flag OR Function was added by QML
-        quint16 isWritableORhasArguments    : 1; // Has WRITE function OR Function takes arguments
-        quint16 isResettableORisSignal      : 1; // Has RESET function OR Function is a signal
-        quint16 isAliasORisVMESignal        : 1; // Is a QML alias to another property OR Signal was added by QML
-        quint16 isFinalORisV4Function       : 1; // Has FINAL flag OR Function takes QQmlV4Function* args
-        quint16 isSignalHandler             : 1; // Function is a signal handler
-        quint16 isOverload                  : 1; // Function is an overload of another function
-        quint16 isRequiredORisCloned        : 1; // Has REQUIRED flag OR The function was marked as cloned
-        quint16 isConstructor               : 1; // The function was marked is a constructor
-        quint16 isDirect                    : 1; // Exists on a C++ QMetaObject
-        quint16 isOverridden                : 1; // Is overridden by a extension property
+        unsigned isConstantORisVMEFunction     : 1; // Has CONST flag OR Function was added by QML
+        unsigned isWritableORhasArguments      : 1; // Has WRITE function OR Function takes arguments
+        unsigned isResettableORisSignal        : 1; // Has RESET function OR Function is a signal
+        unsigned isAliasORisVMESignal          : 1; // Is a QML alias to another property OR Signal was added by QML
+        unsigned isFinalORisV4Function         : 1; // Has FINAL flag OR Function takes QQmlV4Function* args
+        unsigned isSignalHandler               : 1; // Function is a signal handler
+        unsigned isOverload                    : 1; // Function is an overload of another function
+        unsigned isRequiredORisCloned          : 1; // Has REQUIRED flag OR The function was marked as cloned
+        unsigned isConstructor                 : 1; // The function was marked is a constructor
+        unsigned isDirect                      : 1; // Exists on a C++ QMetaObject
+        unsigned isOverridden                  : 1; // Is overridden by a extension property
     public:
-        quint16 type                        : 4; // stores an entry of Types
+        unsigned type             : 4; // stores an entry of Types
 
         // Apply only to IsFunctions
 
         // Internal QQmlPropertyCache flags
-        quint16 overrideIndexIsProperty: 1;
+        unsigned notFullyResolved : 1; // True if the type data is to be lazily resolved
+        unsigned overrideIndexIsProperty: 1;
 
         inline Flags();
         inline bool operator==(const Flags &other) const;
@@ -199,12 +208,16 @@ public:
 
     };
 
-    Q_STATIC_ASSERT(sizeof(Flags) == sizeof(quint16));
 
     inline bool operator==(const QQmlPropertyData &) const;
 
     Flags flags() const { return m_flags; }
-    void setFlags(Flags f) { m_flags = f; }
+    void setFlags(Flags f)
+    {
+        unsigned otherBits = m_flags.otherBits;
+        m_flags = f;
+        m_flags.otherBits = otherBits;
+    }
 
     bool isValid() const { return coreIndex() != -1; }
 
@@ -240,26 +253,14 @@ public:
     bool hasOverride() const { return overrideIndex() >= 0; }
     bool hasRevision() const { return revision() != 0; }
 
-    // This is unsafe in the general case. The property might be in the process of getting
-    // resolved. Only use it if this case has been taken into account.
-    bool isResolved() const { return m_propTypeAndRelativePropIndex != 0; }
-
-    int propType() const
-    {
-        const quint32 type = m_propTypeAndRelativePropIndex & PropTypeMask;
-        Q_ASSERT(type > 0); // Property has to be fully resolved.
-        return type == PropTypeUnknown ? 0 : type;
-    }
+    bool isFullyResolved() const { return !m_flags.notFullyResolved; }
 
+    int propType() const { Q_ASSERT(isFullyResolved()); return m_propType; }
     void setPropType(int pt)
     {
-        // You can only directly set the property type if you own the QQmlPropertyData.
-        // It must not be exposed to other threads before setting the type!
         Q_ASSERT(pt >= 0);
-        Q_ASSERT(uint(pt) < PropTypeUnknown);
-        m_propTypeAndRelativePropIndex
-                = (m_propTypeAndRelativePropIndex & RelativePropIndexMask)
-                    | (pt == 0 ? PropTypeUnknown : quint32(pt));
+        Q_ASSERT(pt <= std::numeric_limits<qint16>::max());
+        m_propType = quint16(pt);
     }
 
     int notifyIndex() const { return m_notifyIndex; }
@@ -322,10 +323,7 @@ public:
     }
 
     QQmlPropertyCacheMethodArguments *arguments() const { return m_arguments; }
-    bool setArguments(QQmlPropertyCacheMethodArguments *args)
-    {
-        return m_arguments.testAndSetRelease(nullptr, args);
-    }
+    void setArguments(QQmlPropertyCacheMethodArguments *args) { m_arguments = args; }
 
     int metaObjectOffset() const { return m_metaObjectOffset; }
     void setMetaObjectOffset(int off)
@@ -338,26 +336,12 @@ public:
     StaticMetaCallFunction staticMetaCallFunction() const { return m_staticMetaCallFunction; }
     void trySetStaticMetaCallFunction(StaticMetaCallFunction f, unsigned relativePropertyIndex)
     {
-        if (relativePropertyIndex > std::numeric_limits<quint16>::max())
-            return;
-
-        const quint16 propType = m_propTypeAndRelativePropIndex & PropTypeMask;
-        if (propType > 0) {
-            // We can do this because we know that resolve() has run at this point
-            // and we don't need to synchronize anymore. If we get a 0, that means it hasn't
-            // run or is currently in progress. We don't want to interfer and just go through
-            // the meta object.
-            m_propTypeAndRelativePropIndex
-                    = propType | (relativePropertyIndex << RelativePropIndexShift);
+        if (relativePropertyIndex < (1 << Flags::BitsLeftInFlags) - 1) {
+            m_flags.otherBits = relativePropertyIndex;
             m_staticMetaCallFunction = f;
         }
     }
-
-    quint16 relativePropertyIndex() const
-    {
-        Q_ASSERT(hasStaticMetaCallFunction());
-        return m_propTypeAndRelativePropIndex >> 16;
-    }
+    quint16 relativePropertyIndex() const { Q_ASSERT(hasStaticMetaCallFunction()); return m_flags.otherBits; }
 
     static Flags flagsForProperty(const QMetaProperty &);
     void load(const QMetaProperty &);
@@ -417,17 +401,11 @@ private:
     friend class QQmlPropertyCache;
     void lazyLoad(const QMetaProperty &);
     void lazyLoad(const QMetaMethod &);
-
-    enum {
-        PropTypeMask           = 0x0000ffff,
-        RelativePropIndexMask  = 0xffff0000,
-        RelativePropIndexShift = 16,
-        PropTypeUnknown        = std::numeric_limits<quint16>::max(),
-    };
-    QAtomicInteger<quint32> m_propTypeAndRelativePropIndex;
+    bool notFullyResolved() const { return m_flags.notFullyResolved; }
 
     Flags m_flags;
     qint16 m_coreIndex = -1;
+    quint16 m_propType = 0;
 
     // The notify index is in the range returned by QObjectPrivate::signalIndex().
     // This is different from QMetaMethod::methodIndex().
@@ -438,7 +416,7 @@ private:
     quint8 m_typeMinorVersion = 0;
     qint16 m_metaObjectOffset = -1;
 
-    QAtomicPointer<QQmlPropertyCacheMethodArguments> m_arguments;
+    QQmlPropertyCacheMethodArguments *m_arguments = nullptr;
     StaticMetaCallFunction m_staticMetaCallFunction = nullptr;
 };
 
@@ -458,7 +436,8 @@ bool QQmlPropertyData::operator==(const QQmlPropertyData &other) const
 }
 
 QQmlPropertyData::Flags::Flags()
-    : isConstantORisVMEFunction(false)
+    : otherBits(0)
+    , isConstantORisVMEFunction(false)
     , isWritableORhasArguments(false)
     , isResettableORisSignal(false)
     , isAliasORisVMESignal(false)
@@ -470,6 +449,7 @@ QQmlPropertyData::Flags::Flags()
     , isDirect(false)
     , isOverridden(false)
     , type(OtherType)
+    , notFullyResolved(false)
     , overrideIndexIsProperty(false)
 {}
 
@@ -485,6 +465,7 @@ bool QQmlPropertyData::Flags::operator==(const QQmlPropertyData::Flags &other) c
             isRequiredORisCloned == other.isRequiredORisCloned &&
             type == other.type &&
             isConstructor == other.isConstructor &&
+            notFullyResolved == other.notFullyResolved &&
             overrideIndexIsProperty == other.overrideIndexIsProperty;
 }
 
diff --git a/src/qmlmodels/qqmldelegatemodel.cpp b/src/qmlmodels/qqmldelegatemodel.cpp
index 2079a8ed04..f5d586a4c2 100644
--- a/src/qmlmodels/qqmldelegatemodel.cpp
+++ b/src/qmlmodels/qqmldelegatemodel.cpp
@@ -389,6 +389,12 @@ void QQmlDelegateModelPrivate::connectToAbstractItemModel()
                       q,  QQmlDelegateModel, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
                       q,  QQmlDelegateModel, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsInserted(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsRemoved(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                       q, QQmlDelegateModel, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -413,6 +419,12 @@ void QQmlDelegateModelPrivate::disconnectFromAbstractItemModel()
                         q, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
     QObject::disconnect(aim, SIGNAL(rowsRemoved(QModelIndex,int,int)),
                         q, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsInserted(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsRemoved(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)), q,
+                        SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     QObject::disconnect(aim, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                         q, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     QObject::disconnect(aim, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -968,17 +980,6 @@ void QQDMIncubationTask::initializeRequiredProperties(QQmlDelegateModelItem *mod
             contextData->extraObject = modelItemToIncubate;
         }
 
-        // If we have required properties, we clear the context object
-        // so that the model role names are not polluting the context
-        if (incubating) {
-            Q_ASSERT(incubating->contextData);
-            incubating->contextData->contextObject = nullptr;
-        }
-
-        if (proxyContext) {
-            proxyContext->contextObject = nullptr;
-        }
-
         if (incubatorPriv->requiredProperties().empty())
             return;
         RequiredProperties &requiredProperties = incubatorPriv->requiredProperties();
@@ -1290,7 +1291,6 @@ QObject *QQmlDelegateModelPrivate::object(Compositor::Group group, int index, QQ
 
         QQmlContextData *ctxt = new QQmlContextData;
         ctxt->setParent(QQmlContextData::get(creationContext  ? creationContext : m_context.data()));
-        ctxt->contextObject = cacheItem;
         cacheItem->contextData = ctxt;
 
         if (m_adaptorModel.hasProxyObject()) {
@@ -1301,7 +1301,6 @@ QObject *QQmlDelegateModelPrivate::object(Compositor::Group group, int index, QQ
                 QObject *proxied = proxy->proxiedObject();
                 cacheItem->incubationTask->proxiedObject = proxied;
                 cacheItem->incubationTask->proxyContext = ctxt;
-                ctxt->contextObject = cacheItem;
                 // We don't own the proxied object. We need to clear it if it goes away.
                 QObject::connect(proxied, &QObject::destroyed,
                                  cacheItem, &QQmlDelegateModelItem::childContextObjectDestroyed);
@@ -1973,6 +1972,38 @@ void QQmlDelegateModel::_q_rowsMoved(
     }
 }
 
+void QQmlDelegateModel::_q_columnsInserted(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsRemoved(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsMoved(const QModelIndex &parent, int start, int end,
+                                        const QModelIndex &destination, int column)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if ((parent == d->m_adaptorModel.rootIndex && start == 0)
+        || (destination == d->m_adaptorModel.rootIndex && column == 0)) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
 void QQmlDelegateModel::_q_dataChanged(const QModelIndex &begin, const QModelIndex &end, const QVector<int> &roles)
 {
     Q_D(QQmlDelegateModel);
diff --git a/src/qmlmodels/qqmldelegatemodel_p.h b/src/qmlmodels/qqmldelegatemodel_p.h
index 8aab4badca..d140bfbaaf 100644
--- a/src/qmlmodels/qqmldelegatemodel_p.h
+++ b/src/qmlmodels/qqmldelegatemodel_p.h
@@ -152,6 +152,9 @@ private Q_SLOTS:
     void _q_itemsMoved(int from, int to, int count);
     void _q_modelReset();
     void _q_rowsInserted(const QModelIndex &,int,int);
+    void _q_columnsInserted(const QModelIndex &, int, int);
+    void _q_columnsRemoved(const QModelIndex &, int, int);
+    void _q_columnsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
     void _q_rowsAboutToBeRemoved(const QModelIndex &parent, int begin, int end);
     void _q_rowsRemoved(const QModelIndex &,int,int);
     void _q_rowsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
diff --git a/src/quick/accessible/qaccessiblequickitem.cpp b/src/quick/accessible/qaccessiblequickitem.cpp
index 85719fdc80..5e1ae25c38 100644
--- a/src/quick/accessible/qaccessiblequickitem.cpp
+++ b/src/quick/accessible/qaccessiblequickitem.cpp
@@ -216,8 +216,6 @@ QAccessible::Role QAccessibleQuickItem::role() const
     if (role == QAccessible::NoRole) {
         if (qobject_cast<QQuickText*>(const_cast<QQuickItem *>(item())))
             role = QAccessible::StaticText;
-        else if (qobject_cast<QQuickTextInput*>(const_cast<QQuickItem *>(item())))
-            role = QAccessible::EditableText;
         else
             role = QAccessible::Client;
     }
@@ -234,7 +232,6 @@ QStringList QAccessibleQuickItem::actionNames() const
 {
     QStringList actions;
     switch (role()) {
-    case QAccessible::Link:
     case QAccessible::PushButton:
         actions << QAccessibleActionInterface::pressAction();
         break;
diff --git a/src/quick/designer/qquickdesignersupportproperties.cpp b/src/quick/designer/qquickdesignersupportproperties.cpp
index 479e77bf68..fb6a5fb324 100644
--- a/src/quick/designer/qquickdesignersupportproperties.cpp
+++ b/src/quick/designer/qquickdesignersupportproperties.cpp
@@ -126,15 +126,16 @@ void QQuickDesignerSupportProperties::getPropertyCache(QObject *object, QQmlEngi
     QQmlEnginePrivate::get(engine)->cache(object->metaObject());
 }
 
-static QQuickDesignerSupport::PropertyNameList propertyNameListForWritableProperties(QObject *object,
+QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::propertyNameListForWritableProperties(QObject *object,
                                                        const QQuickDesignerSupport::PropertyName &baseName,
-                                                       QObjectList *inspectedObjects,
-                                                       int depth = 0)
+                                                       QObjectList *inspectedObjects)
 {
     QQuickDesignerSupport::PropertyNameList propertyNameList;
 
-    if (depth > 2)
-        return propertyNameList;
+    QObjectList localObjectList;
+
+    if (inspectedObjects == nullptr)
+        inspectedObjects = &localObjectList;
 
     if (!inspectedObjects->contains(object))
         inspectedObjects->append(object);
@@ -149,16 +150,14 @@ static QQuickDesignerSupport::PropertyNameList propertyNameListForWritableProper
                 if (childObject)
                     propertyNameList.append(propertyNameListForWritableProperties(childObject,
                                                                                   baseName +  QQuickDesignerSupport::PropertyName(metaProperty.name())
-                                                                                  + '.', inspectedObjects,
-                                                                                  depth + 1));
+                                                                                  + '.', inspectedObjects));
             }
         } else if (QQmlGadgetPtrWrapper *valueType
                    = QQmlGadgetPtrWrapper::instance(qmlEngine(object), metaProperty.userType())) {
             valueType->setValue(metaProperty.read(object));
             propertyNameList.append(propertyNameListForWritableProperties(valueType,
                                                                           baseName +  QQuickDesignerSupport::PropertyName(metaProperty.name())
-                                                                          + '.', inspectedObjects,
-                                                                          depth + 1));
+                                                                          + '.', inspectedObjects));
         }
 
         if (metaProperty.isReadable() && metaProperty.isWritable()) {
@@ -170,12 +169,6 @@ static QQuickDesignerSupport::PropertyNameList propertyNameListForWritableProper
     return propertyNameList;
 }
 
-QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::propertyNameListForWritableProperties(QObject *object)
-{
-    QObjectList localObjectList;
-    return ::propertyNameListForWritableProperties(object, {}, &localObjectList);
-}
-
 bool QQuickDesignerSupportProperties::isPropertyBlackListed(const QQuickDesignerSupport::PropertyName &propertyName)
 {
     if (propertyName.contains(".") && propertyName.contains("__"))
@@ -189,8 +182,7 @@ bool QQuickDesignerSupportProperties::isPropertyBlackListed(const QQuickDesigner
 
 QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allPropertyNames(QObject *object,
                                   const QQuickDesignerSupport::PropertyName &baseName,
-                                  QObjectList *inspectedObjects,
-                                  int depth)
+                                  QObjectList *inspectedObjects)
 {
     QQuickDesignerSupport::PropertyNameList propertyNameList;
 
@@ -199,9 +191,6 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allProp
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-    if (depth > 2)
-        return propertyNameList;
-
     if (!inspectedObjects->contains(object))
         inspectedObjects->append(object);
 
@@ -225,8 +214,7 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allProp
                     propertyNameList.append(allPropertyNames(childObject,
                                                              baseName
                                                              + QQuickDesignerSupport::PropertyName(metaProperty.name())
-                                                             + '.', inspectedObjects,
-                                                             depth + 1));
+                                                             + '.', inspectedObjects));
             }
         } else if (QQmlGadgetPtrWrapper *valueType
                    = QQmlGadgetPtrWrapper::instance(qmlEngine(object), metaProperty.userType())) {
@@ -235,8 +223,7 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allProp
             propertyNameList.append(allPropertyNames(valueType,
                                                      baseName
                                                      + QQuickDesignerSupport::PropertyName(metaProperty.name())
-                                                     + '.', inspectedObjects,
-                                                     depth + 1));
+                                                     + '.', inspectedObjects));
         } else  {
             addToPropertyNameListIfNotBlackListed(&propertyNameList,
                                                   baseName + QQuickDesignerSupport::PropertyName(metaProperty.name()));
diff --git a/src/quick/designer/qquickdesignersupportproperties_p.h b/src/quick/designer/qquickdesignersupportproperties_p.h
index 5970eca9f1..02e75ea886 100644
--- a/src/quick/designer/qquickdesignersupportproperties_p.h
+++ b/src/quick/designer/qquickdesignersupportproperties_p.h
@@ -90,11 +90,12 @@ public:
 
     static void getPropertyCache(QObject *object, QQmlEngine *engine);
     static bool isPropertyBlackListed(const QQuickDesignerSupport::PropertyName &propertyName);
-    static QQuickDesignerSupport::PropertyNameList propertyNameListForWritableProperties(QObject *object);
+    static QQuickDesignerSupport::PropertyNameList propertyNameListForWritableProperties(QObject *object,
+                                                                  const QQuickDesignerSupport::PropertyName &baseName = QQuickDesignerSupport::PropertyName(),
+                                                                  QObjectList *inspectedObjects = nullptr);
     static QQuickDesignerSupport::PropertyNameList allPropertyNames(QObject *object,
                                              const QQuickDesignerSupport::PropertyName &baseName = QQuickDesignerSupport::PropertyName(),
-                                             QObjectList *inspectedObjects = nullptr,
-                                             int depth = 0);
+                                             QObjectList *inspectedObjects = nullptr);
     static bool hasFullImplementedListInterface(const QQmlListReference &list);
 };
 
diff --git a/src/quick/doc/snippets/pointerHandlers/hoverTapKeyButton.qml b/src/quick/doc/snippets/pointerHandlers/hoverTapKeyButton.qml
deleted file mode 100644
index 1564aa16b5..0000000000
--- a/src/quick/doc/snippets/pointerHandlers/hoverTapKeyButton.qml
+++ /dev/null
@@ -1,73 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2021 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the documentation of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** BSD License Usage
-** Alternatively, you may use this file under the terms of the BSD license
-** as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of The Qt Company Ltd nor the names of its
-**     contributors may be used to endorse or promote products derived
-**     from this software without specific prior written permission.
-**
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-//![0]
-import QtQuick 2.12
-
-Rectangle {
-    id: button
-    signal clicked
-
-    width: 150; height: 50; radius: 3
-    color: tapHandler.pressed ? "goldenrod" : hoverHandler.hovered ? "wheat" : "beige"
-    border.color: activeFocus ? "brown" : "transparent"
-    focus: true
-
-    HoverHandler {
-        id: hoverHandler
-    }
-
-    TapHandler {
-        id: tapHandler
-        onTapped: button.clicked()
-    }
-
-    Keys.onEnterPressed: button.clicked()
-}
-//![0]
diff --git a/src/quick/doc/snippets/qml/externaldrag.qml b/src/quick/doc/snippets/qml/externaldrag.qml
index 5a88be2d4b..97a23293ca 100644
--- a/src/quick/doc/snippets/qml/externaldrag.qml
+++ b/src/quick/doc/snippets/qml/externaldrag.qml
@@ -48,7 +48,7 @@
 **
 ****************************************************************************/
 //![0]
-import QtQuick 2.12
+import QtQuick 2.8
 
 Item {
     width: 200; height: 200
@@ -59,7 +59,7 @@ Item {
         color: "green"
         radius: 5
 
-        Drag.active: dragHandler.active
+        Drag.active: dragArea.drag.active
         Drag.dragType: Drag.Automatic
         Drag.supportedActions: Qt.CopyAction
         Drag.mimeData: {
@@ -72,14 +72,14 @@ Item {
             text: "Drag me"
         }
 
-        DragHandler {
-            id: dragHandler
-            onActiveChanged:
-                if (active) {
-                    parent.grabToImage(function(result) {
-                        parent.Drag.imageSource = result.url;
-                    })
-                }
+        MouseArea {
+            id: dragArea
+            anchors.fill: parent
+
+            drag.target: parent
+            onPressed: parent.grabToImage(function(result) {
+                parent.Drag.imageSource = result.url
+            })
         }
     }
 }
diff --git a/src/quick/doc/src/concepts/inputhandlers/qtquickhandlers-index.qdoc b/src/quick/doc/src/concepts/inputhandlers/qtquickhandlers-index.qdoc
index bf889a9066..2ac9860e6f 100644
--- a/src/quick/doc/src/concepts/inputhandlers/qtquickhandlers-index.qdoc
+++ b/src/quick/doc/src/concepts/inputhandlers/qtquickhandlers-index.qdoc
@@ -1,6 +1,6 @@
 /****************************************************************************
 **
-** Copyright (C) 2021 The Qt Company Ltd.
+** Copyright (C) 2018 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the documentation of the Qt Toolkit.
@@ -30,21 +30,20 @@
     \title Qt Quick Input Handlers
     \brief A module with a set of QML elements that handle events from input devices in a user interface.
 
-    Qt Quick Input Handlers are a set of QML types used to handle
-    \l {QInputEvent}{events} from keyboard, touch, mouse, and stylus
-    \l {QInputDevice}{devices} in a UI. In contrast to event-handling
-    items, such as \l MouseArea and \l Flickable, input handlers are explicitly
-    non-visual, require less memory and are intended to be used in greater
-    numbers: one handler instance per aspect of interaction. Each input handler
-    instance handles certain events on behalf of its
-    \l {QQuickPointerHandler::parent()}{parent} Item. Thus the visual and
+    Qt Quick Input Handlers are a set of QML types used to handle events from
+    keyboard, touch, mouse, and stylus devices in a UI. In contrast to event-handling
+    items, such as \l MouseArea and \l Flickable, input handlers are explicitly non-visual,
+    require less memory and are intended to be used in greater numbers: one
+    handler instance per aspect of interaction. Each input handler instance
+    handles certain events on behalf of its \c parent Item. Thus the visual and
     behavioral concerns are better separated, and the behavior is built up by
     finer-grained composition.
 
-    The pre-existing \l Keys attached property is similar in concept, so we
-    refer to the pointing-device-oriented handlers plus \c Keys together as the
-    set of Input Handlers. We expect to offer more attached-property use cases
-    in future versions of Qt.
+    In Qt 5.10, these handlers were introduced in a separate Qt.labs.handlers module.
+    Now they are included with Qt Quick since 5.12.  The pre-existing
+    \l Keys attached property is similar in concept, so we refer to the
+    pointing-device-oriented handlers plus \c Keys together as the set of Input Handlers.
+    We expect to offer more attached-property use cases in future versions of Qt.
 
     \section1 Input Handlers
 
@@ -61,44 +60,7 @@
         \li Each Item can have unlimited Handlers
     \endlist
 
-    \section1 Handlers Manipulating Items
-
-    Some Handlers add interactivity simply by being declared inside an Item:
-
-    \snippet pointerHandlers/dragHandler.qml 0
-
-    \section1 Handler Properties and Signals
-
-    All Handlers have properties that can be used in bindings, and signals that
-    can be handled to react to input:
-
-    \snippet pointerHandlers/hoverTapKeyButton.qml 0
-
-    \section1 Pointer Grab
-
-    An important concept with Pointer Handlers is the type of grabs that they
-    perform. The only kind of grab an Item can take is the exclusive grab: for
-    example if you call \l QPointerEvent::setExclusiveGrabber(), the following
-    mouse moves and mouse release event will be sent only to that object. (As a
-    workaround to this exclusivity, see \l QQuickItem::setFiltersChildMouseEvents()
-    and \l QQuickItem::childMouseEventFilter().) However Pointer Handlers have
-    an additional mechanism available: the
-    \l {QPointerEvent::addPassiveGrabber()} {passive grab}. Mouse and touch
-    \l {QEventPoint::state()}{press} events are delivered by visiting all the
-    Items in top-down Z order: first each Item's child Handlers, and then the
-    \l {QQuickItem::event()}{Item} itself. At the time a press event is
-    delivered, a Handler can take either a passive or an exclusive grab
-    depending on its needs. If it takes a passive grab, it is guaranteed to
-    receive the updates and the release, even if other Items or Handlers in the
-    scene take any kind of grab, passive or exclusve. Some Handlers (such as
-    PointHandler) can work only with passive grabs; others require exclusive
-    grabs; and others can "lurk" with passive grabs until they detect that a
-    gesture is being performed, and then make the transition from passive to
-    exclusive grab.
-
-    When a grab transition is requested, \l PointerHandler::grabPermissions,
-    \l QQuickItem::keepMouseGrab() and \l QQuickItem::keepTouchGrab() control
-    whether the transition will be allowed.
+    \omit TODO actual overview with snippets and stuff \endomit
 
     \section1 Related Information
 
diff --git a/src/quick/doc/src/qmltypereference.qdoc b/src/quick/doc/src/qmltypereference.qdoc
index 65de1284a4..528444cad3 100644
--- a/src/quick/doc/src/qmltypereference.qdoc
+++ b/src/quick/doc/src/qmltypereference.qdoc
@@ -739,73 +739,6 @@ console.log(c + " " + d); // false true
         \li Description
         \li Example
 
-        \row
-        \li translate(vector3d vector)
-        \li Multiplies \c this matrix4x4 by another that translates coordinates by the components
-            of \c vector
-        \li \code
-var m = Qt.matrix4x4();
-m.translate(Qt.vector3d(1,2,3));
-console.log(m.toString());
-// QMatrix4x4(1, 0, 0, 1, 0, 1, 0, 2, 0, 0, 1, 3, 0, 0, 0, 1)
-            \endcode
-
-        \row
-        \li rotate(real angle, vector3d axis)
-        \li Multiples \c this matrix4x4 by another that rotates coordinates through
-            \c angle degrees about \c axis
-        \li \code
-var m = Qt.matrix4x4();
-m.rotate(180,vector3d(1,0,0));
-console.log(m.toString());
-// QMatrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1)
-            \endcode
-
-        \row
-        \li scale(real factor)
-        \li Multiplies \c this matrix4x4 by another that scales coordinates by the given \c factor
-        \li \code
-var m = Qt.matrix4x4();
-m.scale(2);
-console.log(m.toString());
-// QMatrix4x4(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1)
-            \endcode
-
-        \row
-        \li scale(real x, real y, real z)
-        \li Multiplies \c this matrix4x4 by another that scales coordinates by the components
-            \c x, \c y, and \c z
-        \li \code
-var m = Qt.matrix4x4();
-m.scale(1,2,3);
-console.log(m.toString());
-// QMatrix4x4(1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1)
-            \endcode
-
-        \row
-        \li scale(vector3d vector)
-        \li Multiplies \c this matrix4x4 by another that scales coordinates by the components
-            of \c vector
-        \li \code
-var m = Qt.matrix4x4();
-m.scale(Qt.vector3d(1,2,3));
-console.log(m.toString());
-// QMatrix4x4(1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1)
-            \endcode
-
-        \row
-        \li lookAt(vector3d eye, vector3d center, vector3d up)
-        \li Multiplies \c this matrix4x4 by a viewing matrix derived from an \c eye point.
-            The \c center vector3d indicates the center of the view that the \c eye is looking at.
-            The \c up vector3d indicates which direction should be considered up with respect to
-            the \c eye.
-        \li \code
-var m = Qt.matrix4x4();
-m.lookAt(Qt.vector3d(1,2,3),Qt.vector3d(1,2,0),Qt.vector3d(0,1,0));
-console.log(m.toString());
-// QMatrix4x4(1, 0, 0, -1, 0, 1, 0, -2, 0, 0, 1, -3, 0, 0, 0, 1)
-            \endcode
-
         \row
         \li matrix4x4 times(matrix4x4 other)
         \li Returns the matrix4x4 result of multiplying \c this matrix4x4 with
diff --git a/src/quick/handlers/qquickmultipointhandler.cpp b/src/quick/handlers/qquickmultipointhandler.cpp
index 2a9ecd341c..f404788de4 100644
--- a/src/quick/handlers/qquickmultipointhandler.cpp
+++ b/src/quick/handlers/qquickmultipointhandler.cpp
@@ -146,7 +146,7 @@ void QQuickMultiPointHandler::onActiveChanged()
     }
 }
 
-void QQuickMultiPointHandler::onGrabChanged(QQuickPointerHandler *grabber, QQuickEventPoint::GrabTransition transition, QQuickEventPoint *point)
+void QQuickMultiPointHandler::onGrabChanged(QQuickPointerHandler *, QQuickEventPoint::GrabTransition transition, QQuickEventPoint *)
 {
     Q_D(QQuickMultiPointHandler);
     // If another handler or item takes over this set of points, assume it has
@@ -155,20 +155,6 @@ void QQuickMultiPointHandler::onGrabChanged(QQuickPointerHandler *grabber, QQuic
     // (e.g. between DragHandler and PinchHandler).
     if (transition == QQuickEventPoint::UngrabExclusive || transition == QQuickEventPoint::CancelGrabExclusive)
         d->currentPoints.clear();
-    if (grabber != this)
-        return;
-    switch (transition) {
-    case QQuickEventPoint::GrabExclusive:
-    case QQuickEventPoint::GrabPassive:
-    case QQuickEventPoint::UngrabPassive:
-    case QQuickEventPoint::UngrabExclusive:
-    case QQuickEventPoint::CancelGrabPassive:
-    case QQuickEventPoint::CancelGrabExclusive:
-        QQuickPointerHandler::onGrabChanged(grabber, transition, point);
-        break;
-    case QQuickEventPoint::OverrideGrabPassive:
-        return; // don't emit
-    }
 }
 
 QVector<QQuickEventPoint *> QQuickMultiPointHandler::eligiblePoints(QQuickPointerEvent *event)
diff --git a/src/quick/handlers/qquickpointerhandler.cpp b/src/quick/handlers/qquickpointerhandler.cpp
index a6c18feafe..03f8d8918c 100644
--- a/src/quick/handlers/qquickpointerhandler.cpp
+++ b/src/quick/handlers/qquickpointerhandler.cpp
@@ -346,16 +346,10 @@ bool QQuickPointerHandler::approveGrabTransition(QQuickEventPoint *point, QObjec
                         existingPhGrabber->metaObject()->className() == metaObject()->className())
                     allowed = true;
             } else if ((d->grabPermissions & CanTakeOverFromItems)) {
-                allowed = true;
                 QQuickItem * existingItemGrabber = point->grabberItem();
-                QQuickWindowPrivate *winPriv = QQuickWindowPrivate::get(parentItem()->window());
-                const bool isMouse = point->pointerEvent()->asPointerMouseEvent();
-                const bool isTouch = point->pointerEvent()->asPointerTouchEvent();
-                if (existingItemGrabber &&
-                        ((existingItemGrabber->keepMouseGrab() &&
-                          (isMouse || winPriv->isDeliveringTouchAsMouse())) ||
-                         (existingItemGrabber->keepTouchGrab() && isTouch))) {
-                    allowed = false;
+                if (existingItemGrabber && !((existingItemGrabber->keepMouseGrab() && point->pointerEvent()->asPointerMouseEvent()) ||
+                                             (existingItemGrabber->keepTouchGrab() && point->pointerEvent()->asPointerTouchEvent()))) {
+                    allowed = true;
                     // If the handler wants to steal the exclusive grab from an Item, the Item can usually veto
                     // by having its keepMouseGrab flag set.  But an exception is if that Item is a parent that
                     // normally filters events (such as a Flickable): it needs to be possible for e.g. a
@@ -364,19 +358,14 @@ bool QQuickPointerHandler::approveGrabTransition(QQuickEventPoint *point, QObjec
                     // at first and then expects to be able to steal the grab later on.  It cannot respect
                     // Flickable's wishes in that case, because then it would never have a chance.
                     if (existingItemGrabber->keepMouseGrab() &&
-                            existingItemGrabber->filtersChildMouseEvents() && existingItemGrabber->isAncestorOf(parentItem())) {
+                            !(existingItemGrabber->filtersChildMouseEvents() && existingItemGrabber->isAncestorOf(parentItem()))) {
+                        QQuickWindowPrivate *winPriv = QQuickWindowPrivate::get(parentItem()->window());
                         if (winPriv->isDeliveringTouchAsMouse() && point->pointId() == winPriv->touchMouseId) {
-                            qCDebug(lcPointerHandlerGrab) << this << "steals touchpoint" << point->pointId()
-                                << "despite parent touch-mouse grabber with keepMouseGrab=true" << existingItemGrabber;
-                            allowed = true;
+                            qCDebug(lcPointerHandlerGrab) << this << "wants to grab touchpoint" << point->pointId()
+                                << "but declines to steal grab from touch-mouse grabber with keepMouseGrab=true" << existingItemGrabber;
+                            allowed = false;
                         }
                     }
-                    if (!allowed) {
-                        qCDebug(lcPointerHandlerGrab) << this << "wants to grab point" << point->pointId()
-                                << "but declines to steal from grabber" << existingItemGrabber
-                                << "with keepMouseGrab=" << existingItemGrabber->keepMouseGrab()
-                                << "keepTouchGrab=" << existingItemGrabber->keepTouchGrab();
-                    }
                 }
             }
         }
diff --git a/src/quick/handlers/qquicktaphandler.cpp b/src/quick/handlers/qquicktaphandler.cpp
index 2284750f15..f3674d6fa9 100644
--- a/src/quick/handlers/qquicktaphandler.cpp
+++ b/src/quick/handlers/qquicktaphandler.cpp
@@ -209,8 +209,6 @@ void QQuickTapHandler::timerEvent(QTimerEvent *event)
     If the spatial constraint is violated, \l pressed transitions immediately
     from true to false, regardless of the time held.
 
-    The \c gesturePolicy also affects grab behavior as described below.
-
     \value TapHandler.DragThreshold
            (the default value) The event point must not move significantly.
            If the mouse, finger or stylus moves past the system-wide drag
@@ -219,13 +217,11 @@ void QQuickTapHandler::timerEvent(QTimerEvent *event)
            can be useful whenever TapHandler needs to cooperate with other
            input handlers (for example \l DragHandler) or event-handling Items
            (for example QtQuick Controls), because in this case TapHandler
-           will not take the exclusive grab, but merely a
-           \l {QPointerEvent::addPassiveGrabber()}{passive grab}.
+           will not take the exclusive grab, but merely a passive grab.
 
     \value TapHandler.WithinBounds
            If the event point leaves the bounds of the \c parent Item, the tap
-           gesture is canceled. The TapHandler will take the
-           \l {QPointerEvent::setExclusiveGrabber}{exclusive grab} on
+           gesture is canceled. The TapHandler will take the exclusive grab on
            press, but will release the grab as soon as the boundary constraint
            is no longer satisfied.
 
@@ -236,9 +232,8 @@ void QQuickTapHandler::timerEvent(QTimerEvent *event)
            typical behavior for button widgets: you can cancel a click by
            dragging outside the button, and you can also change your mind by
            dragging back inside the button before release. Note that it's
-           necessary for TapHandler to take the
-           \l {QPointerEvent::setExclusiveGrabber}{exclusive grab} on press
-           and retain it until release in order to detect this gesture.
+           necessary for TapHandler take the exclusive grab on press and retain
+           it until release in order to detect this gesture.
 */
 void QQuickTapHandler::setGesturePolicy(QQuickTapHandler::GesturePolicy gesturePolicy)
 {
diff --git a/src/quick/items/context2d/qquickcontext2dcommandbuffer.cpp b/src/quick/items/context2d/qquickcontext2dcommandbuffer.cpp
index 1d047e3c2f..55ebbe907c 100644
--- a/src/quick/items/context2d/qquickcontext2dcommandbuffer.cpp
+++ b/src/quick/items/context2d/qquickcontext2dcommandbuffer.cpp
@@ -375,10 +375,7 @@ void QQuickContext2DCommandBuffer::replay(QPainter* p, QQuickContext2D::State& s
             }
             state.lineDash = pattern;
             QPen nPen = p->pen();
-            if (count > 0)
-                nPen.setDashPattern(pattern);
-            else
-                nPen.setStyle(Qt::SolidLine);
+            nPen.setDashPattern(pattern);
             p->setPen(nPen);
             break;
         }
diff --git a/src/quick/items/qquickdroparea.cpp b/src/quick/items/qquickdroparea.cpp
index e503cd7815..d90ee209d6 100644
--- a/src/quick/items/qquickdroparea.cpp
+++ b/src/quick/items/qquickdroparea.cpp
@@ -91,7 +91,6 @@ QQuickDropAreaPrivate::~QQuickDropAreaPrivate()
 /*!
     \qmltype DropArea
     \instantiates QQuickDropArea
-    \inherits Item
     \inqmlmodule QtQuick
     \ingroup qtquick-input
     \brief For specifying drag and drop handling in an area.
diff --git a/src/quick/items/qquickflickable.cpp b/src/quick/items/qquickflickable.cpp
index 9a68be4c49..2a5b16c31a 100644
--- a/src/quick/items/qquickflickable.cpp
+++ b/src/quick/items/qquickflickable.cpp
@@ -62,6 +62,8 @@
 QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(lcHandlerParent)
+Q_LOGGING_CATEGORY(lcWheel, "qt.quick.flickable.wheel")
+Q_LOGGING_CATEGORY(lcVel, "qt.quick.flickable.velocity")
 
 // FlickThreshold determines how far the "mouse" must have moved
 // before we perform a flick.
@@ -263,7 +265,8 @@ QQuickFlickablePrivate::QQuickFlickablePrivate()
     , deceleration(QML_FLICK_DEFAULTDECELERATION)
     , maxVelocity(QML_FLICK_DEFAULTMAXVELOCITY), reportedVelocitySmoothing(100)
     , delayedPressEvent(nullptr), pressDelay(0), fixupDuration(400)
-    , flickBoost(1.0), fixupMode(Normal), vTime(0), visibleArea(nullptr)
+    , flickBoost(1.0), initialWheelFlickDistance(qApp->styleHints()->wheelScrollLines() * 24)
+    , fixupMode(Normal), vTime(0), visibleArea(nullptr)
     , flickableDirection(QQuickFlickable::AutoFlickDirection)
     , boundsBehavior(QQuickFlickable::DragAndOvershootBounds)
     , boundsMovement(QQuickFlickable::FollowBoundsBehavior)
@@ -531,10 +534,14 @@ void QQuickFlickablePrivate::updateBeginningEnd()
     if (atBeginning != vData.atBeginning) {
         vData.atBeginning = atBeginning;
         atYBeginningChange = true;
+        if (!vData.moving && atBeginning)
+            vData.smoothVelocity.setValue(0);
     }
     if (atEnd != vData.atEnd) {
         vData.atEnd = atEnd;
         atYEndChange = true;
+        if (!vData.moving && atEnd)
+            vData.smoothVelocity.setValue(0);
     }
 
     // Horizontal
@@ -547,10 +554,14 @@ void QQuickFlickablePrivate::updateBeginningEnd()
     if (atBeginning != hData.atBeginning) {
         hData.atBeginning = atBeginning;
         atXBeginningChange = true;
+        if (!hData.moving && atBeginning)
+            hData.smoothVelocity.setValue(0);
     }
     if (atEnd != hData.atEnd) {
         hData.atEnd = atEnd;
         atXEndChange = true;
+        if (!hData.moving && atEnd)
+            hData.smoothVelocity.setValue(0);
     }
 
     if (vData.extentsChanged) {
@@ -1489,6 +1500,7 @@ void QQuickFlickable::wheelEvent(QWheelEvent *event)
         d->hData.velocity = 0;
         d->timer.start();
         d->maybeBeginDrag(currentTimestamp, event->position());
+        d->lastPosTime = -1;
         break;
     case Qt::NoScrollPhase: // default phase with an ordinary wheel mouse
     case Qt::ScrollUpdate:
@@ -1515,20 +1527,34 @@ void QQuickFlickable::wheelEvent(QWheelEvent *event)
         return;
     }
 
+    qreal elapsed = qreal(currentTimestamp - d->lastPosTime) / qreal(1000);
+    if (elapsed <= 0) {
+        d->lastPosTime = currentTimestamp;
+        qCDebug(lcWheel) << "insufficient elapsed time: can't calculate velocity" << elapsed;
+        return;
+    }
+
     if (event->source() == Qt::MouseEventNotSynthesized || event->pixelDelta().isNull()) {
-        // physical mouse wheel, so use angleDelta
+        // no pixel delta (physical mouse wheel, or "dumb" touchpad), so use angleDelta
         int xDelta = event->angleDelta().x();
         int yDelta = event->angleDelta().y();
+        // For a single "clicky" wheel event (angleDelta +/- 120),
+        // we want flick() to end up moving a distance proportional to QStyleHints::wheelScrollLines().
+        // The decel algo from there is
+        // qreal dist = v2 / (accel * 2.0);
+        // i.e. initialWheelFlickDistance = (120 / dt)^2 / (deceleration * 2)
+        // now solve for dt:
+        // dt = 120 / sqrt(deceleration * 2 * initialWheelFlickDistance)
+        if (!isMoving())
+            elapsed = 120 / qSqrt(d->deceleration * 2 * d->initialWheelFlickDistance);
         if (yflick() && yDelta != 0) {
-            bool valid = false;
-            if (yDelta > 0 && contentY() > -minYExtent()) {
-                d->vData.velocity = qMax(yDelta*2 - d->vData.smoothVelocity.value(), qreal(d->maxVelocity/4));
-                valid = true;
-            } else if (yDelta < 0 && contentY() < -maxYExtent()) {
-                d->vData.velocity = qMin(yDelta*2 - d->vData.smoothVelocity.value(), qreal(-d->maxVelocity/4));
-                valid = true;
-            }
-            if (valid) {
+            qreal instVelocity = yDelta / elapsed;
+            // if the direction has changed, start over with filtering, to allow instant movement in the opposite direction
+            if ((instVelocity < 0 && d->vData.velocity > 0) || (instVelocity > 0 && d->vData.velocity < 0))
+                d->vData.velocityBuffer.clear();
+            d->vData.addVelocitySample(instVelocity, d->maxVelocity);
+            d->vData.updateVelocity();
+            if ((yDelta > 0 && contentY() > -minYExtent()) || (yDelta < 0 && contentY() < -maxYExtent())) {
                 d->flickY(d->vData.velocity);
                 d->flickingStarted(false, true);
                 if (d->vData.flicking) {
@@ -1539,15 +1565,13 @@ void QQuickFlickable::wheelEvent(QWheelEvent *event)
             }
         }
         if (xflick() && xDelta != 0) {
-            bool valid = false;
-            if (xDelta > 0 && contentX() > -minXExtent()) {
-                d->hData.velocity = qMax(xDelta*2 - d->hData.smoothVelocity.value(), qreal(d->maxVelocity/4));
-                valid = true;
-            } else if (xDelta < 0 && contentX() < -maxXExtent()) {
-                d->hData.velocity = qMin(xDelta*2 - d->hData.smoothVelocity.value(), qreal(-d->maxVelocity/4));
-                valid = true;
-            }
-            if (valid) {
+            qreal instVelocity = xDelta / elapsed;
+            // if the direction has changed, start over with filtering, to allow instant movement in the opposite direction
+            if ((instVelocity < 0 && d->hData.velocity > 0) || (instVelocity > 0 && d->hData.velocity < 0))
+                d->hData.velocityBuffer.clear();
+            d->hData.addVelocitySample(instVelocity, d->maxVelocity);
+            d->hData.updateVelocity();
+            if ((xDelta > 0 && contentX() > -minXExtent()) || (xDelta < 0 && contentX() < -maxXExtent())) {
                 d->flickX(d->hData.velocity);
                 d->flickingStarted(true, false);
                 if (d->hData.flicking) {
@@ -1562,18 +1586,13 @@ void QQuickFlickable::wheelEvent(QWheelEvent *event)
         int xDelta = event->pixelDelta().x();
         int yDelta = event->pixelDelta().y();
 
-        qreal elapsed = qreal(currentTimestamp - d->lastPosTime) / 1000.;
-        if (elapsed <= 0) {
-            d->lastPosTime = currentTimestamp;
-            return;
-        }
         QVector2D velocity(xDelta / elapsed, yDelta / elapsed);
-        d->lastPosTime = currentTimestamp;
         d->accumulatedWheelPixelDelta += QVector2D(event->pixelDelta());
         d->drag(currentTimestamp, event->type(), event->position(), d->accumulatedWheelPixelDelta,
                 true, !d->scrollingPhase, true, velocity);
         event->accept();
     }
+    d->lastPosTime = currentTimestamp;
 
     if (!event->isAccepted())
         QQuickItem::wheelEvent(event);
@@ -1744,6 +1763,10 @@ void QQuickFlickable::componentComplete()
         setContentX(-minXExtent());
     if (!d->vData.explicitValue && d->vData.startMargin != 0.)
         setContentY(-minYExtent());
+    if (lcWheel().isDebugEnabled() || lcVel().isDebugEnabled()) {
+        d->timeline.setObjectName(QLatin1String("timeline for Flickable ") + objectName());
+        d->velocityTimeline.setObjectName(QLatin1String("velocity timeline for Flickable ") + objectName());
+    }
 }
 
 void QQuickFlickable::viewportMoved(Qt::Orientations orient)
@@ -2491,9 +2514,23 @@ void QQuickFlickable::setMaximumFlickVelocity(qreal v)
 
 /*!
     \qmlproperty real QtQuick::Flickable::flickDeceleration
-    This property holds the rate at which a flick will decelerate.
-
-    The default value is platform dependent.
+    This property holds the rate at which a flick will decelerate:
+    the higher the number, the faster it slows down when the user stops
+    flicking via touch, touchpad or mouse wheel. For example 0.0001 is nearly
+    "frictionless", and 10000 feels quite "sticky".
+
+    The default value is platform dependent. Values of zero or less are not allowed.
+
+    \note For touchpad flicking, some platforms drive Flickable directly by
+    sending QWheelEvents with QWheelEvent::phase() being \c Qt::ScrollMomentum,
+    after the user has released all fingers from the touchpad. In that case,
+    the operating system is controlling the deceleration, and this property has
+    no effect.
+
+    \note For mouse wheel scrolling, and for gesture scrolling on touchpads
+    that do not have a momentum phase, extremely large values of
+    flickDeceleration can make Flickable very resistant to scrolling,
+    especially if \l maximumFlickVelocity is too small.
 */
 qreal QQuickFlickable::flickDeceleration() const
 {
@@ -2506,7 +2543,7 @@ void QQuickFlickable::setFlickDeceleration(qreal deceleration)
     Q_D(QQuickFlickable);
     if (deceleration == d->deceleration)
         return;
-    d->deceleration = deceleration;
+    d->deceleration = qMax(0.001, deceleration);
     emit flickDecelerationChanged();
 }
 
diff --git a/src/quick/items/qquickflickable_p_p.h b/src/quick/items/qquickflickable_p_p.h
index 414c9c33d6..6163613493 100644
--- a/src/quick/items/qquickflickable_p_p.h
+++ b/src/quick/items/qquickflickable_p_p.h
@@ -241,6 +241,7 @@ public:
     int pressDelay;
     int fixupDuration;
     qreal flickBoost;
+    qreal initialWheelFlickDistance;
 
     enum FixupMode { Normal, Immediate, ExtentChanged };
     FixupMode fixupMode;
diff --git a/src/quick/items/qquickimage.cpp b/src/quick/items/qquickimage.cpp
index 04c5da6167..1882ec8997 100644
--- a/src/quick/items/qquickimage.cpp
+++ b/src/quick/items/qquickimage.cpp
@@ -343,9 +343,9 @@ void QQuickImage::setFillMode(FillMode mode)
 }
 
 /*!
+
     \qmlproperty real QtQuick::Image::paintedWidth
     \qmlproperty real QtQuick::Image::paintedHeight
-    \readonly
 
     These properties hold the size of the image that is actually painted.
     In most cases it is the same as \c width and \c height, but when using an
@@ -367,7 +367,6 @@ qreal QQuickImage::paintedHeight() const
 
 /*!
     \qmlproperty enumeration QtQuick::Image::status
-    \readonly
 
     This property holds the status of image loading.  It can be one of:
     \list
@@ -405,7 +404,6 @@ qreal QQuickImage::paintedHeight() const
 
 /*!
     \qmlproperty real QtQuick::Image::progress
-    \readonly
 
     This property holds the progress of image loading, from 0.0 (nothing loaded)
     to 1.0 (finished).
@@ -427,7 +425,7 @@ qreal QQuickImage::paintedHeight() const
 */
 
 /*!
-    \qmlproperty size QtQuick::Image::sourceSize
+    \qmlproperty QSize QtQuick::Image::sourceSize
 
     This property holds the scaled width and height of the full-frame image.
 
diff --git a/src/quick/items/qquickimagebase.cpp b/src/quick/items/qquickimagebase.cpp
index d7b5709bb0..8849c2005c 100644
--- a/src/quick/items/qquickimagebase.cpp
+++ b/src/quick/items/qquickimagebase.cpp
@@ -56,8 +56,8 @@ QT_BEGIN_NAMESPACE
 bool QQuickImageBasePrivate::updateDevicePixelRatio(qreal targetDevicePixelRatio)
 {
     // QQuickImageProvider and SVG and PDF can generate a high resolution image when
-    // sourceSize is set. If sourceSize is not set then the provider default size will
-    // be used, as usual.
+    // sourceSize is set (this function is only called if it's set).
+    // If sourceSize is not set then the provider default size will be used, as usual.
     bool setDevicePixelRatio = false;
     if (url.scheme() == QLatin1String("image")) {
         setDevicePixelRatio = true;
@@ -418,14 +418,10 @@ void QQuickImageBase::itemChange(ItemChange change, const ItemChangeData &value)
     Q_D(QQuickImageBase);
     // If the screen DPI changed, reload image.
     if (change == ItemDevicePixelRatioHasChanged && value.realValue != d->devicePixelRatio) {
-        const auto oldDpr = d->devicePixelRatio;
         // ### how can we get here with !qmlEngine(this)? that implies
         // itemChange() on an item pending deletion, which seems strange.
         if (qmlEngine(this) && isComponentComplete() && d->url.isValid()) {
             load();
-            // not changed when loading (sourceSize might not be set)
-            if (d->devicePixelRatio == oldDpr)
-                d->updateDevicePixelRatio(value.realValue);
         }
     }
     QQuickItem::itemChange(change, value);
diff --git a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
index 64123c82c4..83e52b12e5 100644
--- a/src/quick/items/qquickitem.cpp
+++ b/src/quick/items/qquickitem.cpp
@@ -59,6 +59,7 @@
 #include <QtCore/private/qnumeric_p.h>
 #include <QtGui/qpa/qplatformtheme.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/private/qduplicatetracker_p.h>
 
 #include <private/qqmlglobal_p.h>
 #include <private/qqmlengine_p.h>
@@ -2526,6 +2527,7 @@ QQuickItem* QQuickItemPrivate::nextPrevItemInTabFocusChain(QQuickItem *item, boo
     QQuickItem *current = item;
     qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: startItem:" << startItem;
     qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: firstFromItem:" << firstFromItem;
+    QDuplicateTracker<QQuickItem *> cycleDetector;
     do {
         qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: current:" << current;
         qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: from:" << from;
@@ -2592,7 +2594,10 @@ QQuickItem* QQuickItemPrivate::nextPrevItemInTabFocusChain(QQuickItem *item, boo
         // traversed all of the chain (by compare the [current] item with [startItem])
         // Since the [startItem] might be promoted to its parent if it is invisible,
         // we still have to check [current] item with original start item
-        if ((current == startItem || current == originalStartItem) && from == firstFromItem) {
+        // We might also run into a cycle before we reach firstFromItem again
+        // but note that we have to ignore current if we are meant to skip it
+        if (((current == startItem || current == originalStartItem) && from == firstFromItem) ||
+                (!skip && cycleDetector.hasSeen(current))) {
             // wrapped around, avoid endless loops
             if (item == contentItem) {
                 qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: looped, return contentItem";
@@ -4790,24 +4795,14 @@ void QQuickItem::forceActiveFocus()
 
 void QQuickItem::forceActiveFocus(Qt::FocusReason reason)
 {
-    Q_D(QQuickItem);
     setFocus(true, reason);
     QQuickItem *parent = parentItem();
-    QQuickItem *scope = nullptr;
     while (parent) {
         if (parent->flags() & QQuickItem::ItemIsFocusScope) {
             parent->setFocus(true, reason);
-            if (!scope)
-                scope = parent;
         }
         parent = parent->parentItem();
     }
-    // In certain reparenting scenarios, d->focus might be true and the scope
-    // might also have focus, so that setFocus() returns early without actually
-    // acquiring active focus, because it thinks it already has it. In that
-    // case, try to set the DeliveryAgent's active focus. (QTBUG-89736).
-    if (scope && !d->activeFocus && d->window)
-        QQuickWindowPrivate::get(d->window)->setFocusInScope(scope, this, Qt::OtherFocusReason);
 }
 
 /*!
@@ -7868,48 +7863,22 @@ bool QQuickItem::contains(const QPointF &point) const
     \qmlproperty QObject* QtQuick::Item::containmentMask
     \since 5.11
     This property holds an optional mask for the Item to be used in the
-    QtQuick::Item::contains() method. Its main use is currently to determine
-    whether a \l {QPointerEvent}{pointer event} has landed into the item or not.
+    QtQuick::Item::contains method.
+    QtQuick::Item::contains main use is currently to determine whether
+    an input event has landed into the item or not.
 
     By default the \l contains method will return true for any point
-    within the Item's bounding box. \c containmentMask allows for
-    more fine-grained control. For example, if a custom C++
-    QQuickItem subclass with a specialized contains() method
-    is used as containmentMask:
+    within the Item's bounding box. \c containmentMask allows for a
+    more fine-grained control. For example, the developer could
+    define and use an AnotherItem element as containmentMask,
+    which has a specialized contains method, like:
 
     \code
     Item { id: item; containmentMask: AnotherItem { id: anotherItem } }
     \endcode
 
-    \e{item}'s contains method would then return \c true only if
-    \e{anotherItem}'s contains() implementation returns \c true.
-
-    A \l Shape can be used in this way, to make an item react to
-    \l {QPointerEvent}{pointer events} only within a non-rectangular region,
-    as illustrated in the \l {Qt Quick Examples - Shapes}{Shapes example}
-    (see \c tapableTriangle.qml).
-*/
-/*!
-    \property QQuickItem::containmentMask
-    \since 5.11
-    This property holds an optional mask to be used in the contains() method,
-    which is mainly used for hit-testing each \l QPointerEvent.
-
-    By default, \l contains() will return \c true for any point
-    within the Item's bounding box. But any QQuickItem, or any QObject
-    that implements a function of the form
-    \code
-    Q_INVOKABLE bool contains(const QPointF &point) const;
-    \endcode
-    can be used as a mask, to defer hit-testing to that object.
-
-    \note contains() is called frequently during event delivery.
-    Deferring hit-testing to another object slows it down somewhat.
-    containmentMask() can cause performance problems if that object's
-    contains() method is not efficient. If you implement a custom
-    QQuickItem subclass, you can alternatively override contains().
-
-    \sa contains()
+    \e{item}'s contains method would then return true only if
+    \e{anotherItem}'s contains implementation returns true.
 */
 QObject *QQuickItem::containmentMask() const
 {
diff --git a/src/quick/items/qquickloader.cpp b/src/quick/items/qquickloader.cpp
index cb4f79a3c2..7fbe66fdda 100644
--- a/src/quick/items/qquickloader.cpp
+++ b/src/quick/items/qquickloader.cpp
@@ -737,6 +737,9 @@ void QQuickLoaderPrivate::_q_sourceLoaded()
         return;
     }
 
+    if (!active)
+        return;
+
     QQmlContext *creationContext = component->creationContext();
     if (!creationContext) creationContext = qmlContext(q);
     itemContext = new QQmlContext(creationContext);
diff --git a/src/quick/items/qquickmousearea_p_p.h b/src/quick/items/qquickmousearea_p_p.h
index fba383e268..0d63618622 100644
--- a/src/quick/items/qquickmousearea_p_p.h
+++ b/src/quick/items/qquickmousearea_p_p.h
@@ -61,7 +61,6 @@ QT_BEGIN_NAMESPACE
 
 class QQuickMouseEvent;
 class QQuickMouseArea;
-class QQuickPointerMask;
 class QQuickMouseAreaPrivate : public QQuickItemPrivate
 {
     Q_DECLARE_PUBLIC(QQuickMouseArea)
@@ -100,7 +99,6 @@ public:
 #if QT_CONFIG(quick_draganddrop)
     QQuickDrag *drag;
 #endif
-    QPointer<QQuickPointerMask> mask;
     QPointF startScene;
     QPointF targetStartPos;
     QPointF lastPos;
diff --git a/src/quick/items/qquickshadereffectsource.cpp b/src/quick/items/qquickshadereffectsource.cpp
index 4f61d61309..b298ed74da 100644
--- a/src/quick/items/qquickshadereffectsource.cpp
+++ b/src/quick/items/qquickshadereffectsource.cpp
@@ -344,7 +344,6 @@ void QQuickShaderEffectSource::setSourceItem(QQuickItem *item)
             d->refFromEffectItem(m_hideSource);
             d->addItemChangeListener(this, QQuickItemPrivate::Geometry);
             connect(m_sourceItem, SIGNAL(destroyed(QObject*)), this, SLOT(sourceItemDestroyed(QObject*)));
-            connect(m_sourceItem, SIGNAL(parentChanged(QQuickItem*)), this, SLOT(sourceItemParentChanged(QQuickItem*)));
         } else {
             qWarning("ShaderEffectSource: sourceItem and ShaderEffectSource must both be children of the same window.");
             m_sourceItem = nullptr;
@@ -364,13 +363,6 @@ void QQuickShaderEffectSource::sourceItemDestroyed(QObject *item)
 }
 
 
-void QQuickShaderEffectSource::sourceItemParentChanged(QQuickItem *parent)
-{
-    if (!parent && m_texture)
-        m_texture->setItem(0);
-}
-
-
 /*!
     \qmlproperty rect QtQuick::ShaderEffectSource::sourceRect
 
diff --git a/src/quick/items/qquickshadereffectsource_p.h b/src/quick/items/qquickshadereffectsource_p.h
index 4deb6c70a3..c0a1ccab78 100644
--- a/src/quick/items/qquickshadereffectsource_p.h
+++ b/src/quick/items/qquickshadereffectsource_p.h
@@ -173,7 +173,6 @@ Q_SIGNALS:
 private Q_SLOTS:
     void sourceItemDestroyed(QObject *item);
     void invalidateSceneGraph();
-    void sourceItemParentChanged(QQuickItem *parent);
 
 protected:
     void releaseResources() override;
diff --git a/src/quick/items/qquickstateoperations.cpp b/src/quick/items/qquickstateoperations.cpp
index a832f53e39..ddaa1979b6 100644
--- a/src/quick/items/qquickstateoperations.cpp
+++ b/src/quick/items/qquickstateoperations.cpp
@@ -573,7 +573,7 @@ void QQuickParentChange::rewind()
     The AnchorChanges type is used to modify the anchors of an item in a \l State.
 
     AnchorChanges cannot be used to modify the margins on an item. For this, use
-    PropertyChanges instead.
+    PropertyChanges intead.
 
     In the following example we change the top and bottom anchors of an item
     using AnchorChanges, and the top and bottom anchor margins using
diff --git a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
index 6230186933..e823ca1095 100644
--- a/src/quick/items/qquicktext.cpp
+++ b/src/quick/items/qquicktext.cpp
@@ -2168,7 +2168,7 @@ void QQuickText::resetMaximumLineCount()
     <img src="" align="top,middle,bottom" width="" height=""> - inline images
     <ol type="">, <ul type=""> and <li> - ordered and unordered lists
     <pre></pre> - preformatted
-    &gt; &lt; &amp;
+    &gt; &lt; &amp; &quot; &nbsp; &apos;
     \endcode
 
     \c Text.StyledText parser is strict, requiring tags to be correctly nested.
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index b4b64d59cc..0e7f52e816 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -1585,7 +1585,7 @@ void QQuickTextInput::mousePressEvent(QMouseEvent *event)
     d->moveCursor(cursor, mark);
 
     if (d->focusOnPress && !qGuiApp->styleHints()->setFocusOnTouchRelease())
-        ensureActiveFocus(Qt::MouseFocusReason);
+        ensureActiveFocus();
 
     event->setAccepted(true);
 }
@@ -1637,7 +1637,7 @@ void QQuickTextInput::mouseReleaseEvent(QMouseEvent *event)
 #endif
 
     if (d->focusOnPress && qGuiApp->styleHints()->setFocusOnTouchRelease())
-        ensureActiveFocus(Qt::MouseFocusReason);
+        ensureActiveFocus();
 
     if (!event->isAccepted())
         QQuickImplicitSizeItem::mouseReleaseEvent(event);
@@ -1872,10 +1872,10 @@ void QQuickTextInput::invalidateFontCaches()
         d->m_textLayout.engine()->resetFontEngineCache();
 }
 
-void QQuickTextInput::ensureActiveFocus(Qt::FocusReason reason)
+void QQuickTextInput::ensureActiveFocus()
 {
     bool hadActiveFocus = hasActiveFocus();
-    forceActiveFocus(reason);
+    forceActiveFocus();
 #if QT_CONFIG(im)
     Q_D(QQuickTextInput);
     // re-open input panel on press if already focused
diff --git a/src/quick/items/qquicktextinput_p.h b/src/quick/items/qquicktextinput_p.h
index 8e97393d10..9f7b82b168 100644
--- a/src/quick/items/qquicktextinput_p.h
+++ b/src/quick/items/qquicktextinput_p.h
@@ -361,7 +361,7 @@ Q_SIGNALS:
 
 private:
     void invalidateFontCaches();
-    void ensureActiveFocus(Qt::FocusReason reason);
+    void ensureActiveFocus();
 
 protected:
     QQuickTextInput(QQuickTextInputPrivate &dd, QQuickItem *parent = nullptr);
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index 2b9810ed57..c956c85091 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -450,13 +450,12 @@ void QQuickWindow::physicalDpiChanged()
 void QQuickWindow::handleScreenChanged(QScreen *screen)
 {
     Q_D(QQuickWindow);
-    // we connected to the initial screen in QQuickWindowPrivate::init, but the screen changed
     disconnect(d->physicalDpiChangedConnection);
     if (screen) {
         physicalDpiChanged();
         // When physical DPI changes on the same screen, either the resolution or the device pixel
         // ratio changed. We must check what it is. Device pixel ratio does not have its own
-        // ...Changed() signal. Reconnect, same as in QQuickWindowPrivate::init.
+        // ...Changed() signal.
         d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,
                                                   this, &QQuickWindow::physicalDpiChanged);
     }
@@ -708,13 +707,8 @@ void QQuickWindowPrivate::init(QQuickWindow *c, QQuickRenderControl *control)
 
     Q_ASSERT(windowManager || renderControl);
 
-    if (QScreen *screen = q->screen()) {
-        devicePixelRatio = screen->devicePixelRatio();
-        // if the screen changes, then QQuickWindow::handleScreenChanged disconnects
-        // and connects to the new screen
-        physicalDpiChangedConnection = QObject::connect(screen, &QScreen::physicalDotsPerInchChanged,
-                                                        q, &QQuickWindow::physicalDpiChanged);
-    }
+    if (QScreen *screen = q->screen())
+       devicePixelRatio = screen->devicePixelRatio();
 
     QSGContext *sg;
     if (renderControl) {
diff --git a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
index 3c60f830de..0fd6581dc4 100644
--- a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
+++ b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
@@ -428,6 +428,18 @@ QSGTextMaskRhiShader::QSGTextMaskRhiShader(QFontEngine::GlyphFormat glyphFormat)
                       QStringLiteral(":/qt-project.org/scenegraph/shaders_ng/textmask.frag.qsb"));
 }
 
+enum UbufOffset {
+    ModelViewMatrixOffset = 0,
+    ProjectionMatrixOffset = ModelViewMatrixOffset + 64,
+    ColorOffset = ProjectionMatrixOffset + 64,
+    TextureScaleOffset = ColorOffset + 16,
+    DprOffset = TextureScaleOffset + 8,
+
+    // + 1 float padding (vec4 must be aligned to 16)
+    StyleColorOffset = DprOffset + 4 + 4,
+    ShiftOffset = StyleColorOffset + 16
+};
+
 bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
                                              QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
 {
@@ -443,11 +455,14 @@ bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
 
     bool changed = false;
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= DprOffset + 4);
 
     if (state.isMatrixDirty()) {
-        const QMatrix4x4 m = state.combinedMatrix();
-        memcpy(buf->data(), m.constData(), 64);
+        const QMatrix4x4 mv = state.modelViewMatrix();
+        memcpy(buf->data() + ModelViewMatrixOffset, mv.constData(), 64);
+        const QMatrix4x4 p = state.projectionMatrix();
+        memcpy(buf->data() + ProjectionMatrixOffset, p.constData(), 64);
+
         changed = true;
     }
 
@@ -456,13 +471,13 @@ bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
     if (updated || !oldMat || oldRtex != newRtex) {
         const QVector2D textureScale = QVector2D(1.0f / mat->rhiGlyphCache()->width(),
                                                  1.0f / mat->rhiGlyphCache()->height());
-        memcpy(buf->data() + 64 + 16, &textureScale, 8);
+        memcpy(buf->data() + TextureScaleOffset, &textureScale, 8);
         changed = true;
     }
 
     if (!oldMat) {
         float dpr = state.devicePixelRatio();
-        memcpy(buf->data() + 64 + 16 + 8, &dpr, 4);
+        memcpy(buf->data() + DprOffset, &dpr, 4);
     }
 
     // move texture uploads/copies onto the renderer's soon-to-be-committed list
@@ -510,11 +525,11 @@ bool QSG8BitTextMaskRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 80);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -553,12 +568,12 @@ bool QSG24BitTextMaskRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only; coloring happens via the blend constant
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -608,12 +623,12 @@ bool QSG32BitColorTextRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only
         const QVector4D color(0, 0, 0, mat->color().w() * state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -649,20 +664,17 @@ bool QSGStyledTextRhiShader::updateUniformData(RenderState &state,
     QSGStyledTextMaterial *oldMat = static_cast<QSGStyledTextMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 120);
-
-    // matrix..dpr + 1 float padding (vec4 must be aligned to 16)
-    const int startOffset = 64 + 16 + 8 + 4 + 4;
+    Q_ASSERT(buf->size() >= ShiftOffset + 8);
 
     if (oldMat == nullptr || mat->styleColor() != oldMat->styleColor() || state.isOpacityDirty()) {
         const QVector4D styleColor = qsg_premultiply(mat->styleColor(), state.opacity());
-        memcpy(buf->data() + startOffset, &styleColor, 16);
+        memcpy(buf->data() + StyleColorOffset, &styleColor, 16);
         changed = true;
     }
 
     if (oldMat == nullptr || oldMat->styleShift() != mat->styleShift()) {
         const QVector2D v = mat->styleShift();
-        memcpy(buf->data() + startOffset + 16, &v, 8);
+        memcpy(buf->data() + ShiftOffset, &v, 8);
         changed = true;
     }
 
diff --git a/src/quick/scenegraph/qsgrenderloop.cpp b/src/quick/scenegraph/qsgrenderloop.cpp
index ee01211545..c96129e660 100644
--- a/src/quick/scenegraph/qsgrenderloop.cpp
+++ b/src/quick/scenegraph/qsgrenderloop.cpp
@@ -413,6 +413,13 @@ void QSGGuiThreadRenderLoop::windowDestroyed(QQuickWindow *window)
             qCDebug(QSG_LOG_RENDERLOOP, "cleanup without an OpenGL context");
     }
 
+#if QT_CONFIG(quick_shadereffect)
+    QSGRhiShaderEffectNode::cleanupMaterialTypeCache();
+#if QT_CONFIG(opengl)
+    QQuickOpenGLShaderEffectMaterial::cleanupMaterialCache();
+#endif
+#endif
+
     if (d->swapchain) {
         if (window->handle()) {
             // We get here when exiting via QCoreApplication::quit() instead of
@@ -425,14 +432,6 @@ void QSGGuiThreadRenderLoop::windowDestroyed(QQuickWindow *window)
     }
 
     d->cleanupNodesOnShutdown();
-
-#if QT_CONFIG(quick_shadereffect)
-    QSGRhiShaderEffectNode::cleanupMaterialTypeCache();
-#if QT_CONFIG(opengl)
-    QQuickOpenGLShaderEffectMaterial::cleanupMaterialCache();
-#endif
-#endif
-
     if (m_windows.size() == 0) {
         rc->invalidate();
         d->rhi = nullptr;
diff --git a/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp b/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
index 53b6fe117f..219cdd5966 100644
--- a/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
+++ b/src/quick/scenegraph/qsgrhidistancefieldglyphcache.cpp
@@ -446,7 +446,7 @@ bool QSGRhiDistanceFieldGlyphCache::loadPregeneratedCache(const QRawFont &font)
 
         const char *textureRecord = allocatorData;
         for (int i = 0; i < textureCount; ++i, textureRecord += Qtdf::TextureRecordSize) {
-            if (textureRecord + Qtdf::TextureRecordSize > qtdfTableEnd) {
+            if (qtdfTableEnd - textureRecord < Qtdf::TextureRecordSize) {
                 qWarning("qtdf table too small in font '%s'.",
                          qPrintable(font.familyName()));
                 return false;
@@ -462,7 +462,7 @@ bool QSGRhiDistanceFieldGlyphCache::loadPregeneratedCache(const QRawFont &font)
 
         const char *glyphRecord = textureRecord;
         for (quint32 i = 0; i < glyphCount; ++i, glyphRecord += Qtdf::GlyphRecordSize) {
-            if (glyphRecord + Qtdf::GlyphRecordSize > qtdfTableEnd) {
+            if (qtdfTableEnd - glyphRecord < Qtdf:: GlyphRecordSize) {
                 qWarning("qtdf table too small in font '%s'.",
                          qPrintable(font.familyName()));
                 return false;
@@ -512,8 +512,8 @@ bool QSGRhiDistanceFieldGlyphCache::loadPregeneratedCache(const QRawFont &font)
 
             int width = texInfo->allocatedArea.width();
             int height = texInfo->allocatedArea.height();
-            qint64 size = width * height;
-            if (reinterpret_cast<const char *>(textureData + size) > qtdfTableEnd) {
+            qint64 size = qint64(width) * height;
+            if (qtdfTableEnd - reinterpret_cast<const char *>(textureData) < size) {
                 qWarning("qtdf table too small in font '%s'.",
                          qPrintable(font.familyName()));
                 return false;
diff --git a/src/quick/scenegraph/qsgthreadedrenderloop.cpp b/src/quick/scenegraph/qsgthreadedrenderloop.cpp
index d47b0d72a5..1c72c4dba6 100644
--- a/src/quick/scenegraph/qsgthreadedrenderloop.cpp
+++ b/src/quick/scenegraph/qsgthreadedrenderloop.cpp
@@ -547,16 +547,17 @@ void QSGRenderThread::invalidateGraphics(QQuickWindow *window, bool inDestructor
 
     QQuickWindowPrivate *dd = QQuickWindowPrivate::get(window);
 
-    // The canvas nodes must be cleaned up regardless if we are in the destructor..
-    if (wipeSG) {
-        dd->cleanupNodesOnShutdown();
 #if QT_CONFIG(quick_shadereffect)
-        QSGRhiShaderEffectNode::cleanupMaterialTypeCache();
+    QSGRhiShaderEffectNode::cleanupMaterialTypeCache();
 #if QT_CONFIG(opengl)
-        if (current)
-            QQuickOpenGLShaderEffectMaterial::cleanupMaterialCache();
+    if (current)
+        QQuickOpenGLShaderEffectMaterial::cleanupMaterialCache();
 #endif
 #endif
+
+    // The canvas nodes must be cleaned up regardless if we are in the destructor..
+    if (wipeSG) {
+        dd->cleanupNodesOnShutdown();
     } else {
         qCDebug(QSG_LOG_RENDERLOOP, QSG_RT_PAD, "- persistent SG, avoiding cleanup");
         if (current && gl)
diff --git a/src/quick/scenegraph/qsgwindowsrenderloop.cpp b/src/quick/scenegraph/qsgwindowsrenderloop.cpp
index 20e127c49f..20d7c4557f 100644
--- a/src/quick/scenegraph/qsgwindowsrenderloop.cpp
+++ b/src/quick/scenegraph/qsgwindowsrenderloop.cpp
@@ -256,13 +256,12 @@ void QSGWindowsRenderLoop::windowDestroyed(QQuickWindow *window)
     if (Q_UNLIKELY(!current))
         RLDEBUG("cleanup without an OpenGL context");
 
-    d->cleanupNodesOnShutdown();
-
 #if QT_CONFIG(quick_shadereffect) && QT_CONFIG(opengl)
     if (current)
         QQuickOpenGLShaderEffectMaterial::cleanupMaterialCache();
 #endif
 
+    d->cleanupNodesOnShutdown();
     if (m_windows.size() == 0) {
         d->context->invalidate();
         delete m_gl;
diff --git a/src/quick/scenegraph/shaders_ng/24bittextmask.frag b/src/quick/scenegraph/shaders_ng/24bittextmask.frag
index bc3826a924..ed8da4cd30 100644
--- a/src/quick/scenegraph/shaders_ng/24bittextmask.frag
+++ b/src/quick/scenegraph/shaders_ng/24bittextmask.frag
@@ -6,8 +6,9 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
index 63e445f90b..4198a4d339 100644
--- a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
+++ b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
@@ -6,8 +6,9 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/8bittextmask.frag b/src/quick/scenegraph/shaders_ng/8bittextmask.frag
index 6304e821ff..a06743876d 100644
--- a/src/quick/scenegraph/shaders_ng/8bittextmask.frag
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
index 0d0fa1cd3a..f725cbc5e7 100644
--- a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext.frag b/src/quick/scenegraph/shaders_ng/outlinedtext.frag
index 947d161a50..e2f82d3845 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.frag
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.frag
@@ -11,11 +11,12 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext.vert b/src/quick/scenegraph/shaders_ng/outlinedtext.vert
index 023f9dfdc2..4068e42f28 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.vert
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.vert
@@ -10,11 +10,12 @@ layout(location = 3) out vec2 sCoordLeft;
 layout(location = 4) out vec2 sCoordRight;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
@@ -28,6 +29,6 @@ void main()
      sCoordDown = (tCoord - vec2(0.0, 1.0)) * ubuf.textureScale;
      sCoordLeft = (tCoord - vec2(-1.0, 0.0)) * ubuf.textureScale;
      sCoordRight = (tCoord - vec2(1.0, 0.0)) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
index 5b7bd9ca82..274d891a3c 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
@@ -11,11 +11,12 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/styledtext.frag b/src/quick/scenegraph/shaders_ng/styledtext.frag
index 0b16396037..2e380dfeae 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext.frag
+++ b/src/quick/scenegraph/shaders_ng/styledtext.frag
@@ -8,7 +8,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/styledtext.vert b/src/quick/scenegraph/shaders_ng/styledtext.vert
index beadf07c79..271dae8d8a 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext.vert
+++ b/src/quick/scenegraph/shaders_ng/styledtext.vert
@@ -7,7 +7,8 @@ layout(location = 0) out vec2 sampleCoord;
 layout(location = 1) out vec2 shiftedSampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -22,6 +23,6 @@ void main()
 {
      sampleCoord = tCoord * ubuf.textureScale;
      shiftedSampleCoord = (tCoord - ubuf.shift) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/scenegraph/shaders_ng/styledtext_a.frag b/src/quick/scenegraph/shaders_ng/styledtext_a.frag
index b673137895..62e162c851 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext_a.frag
+++ b/src/quick/scenegraph/shaders_ng/styledtext_a.frag
@@ -8,7 +8,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/textmask.frag b/src/quick/scenegraph/shaders_ng/textmask.frag
index 518d5c965f..ed8da4cd30 100644
--- a/src/quick/scenegraph/shaders_ng/textmask.frag
+++ b/src/quick/scenegraph/shaders_ng/textmask.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/textmask.vert b/src/quick/scenegraph/shaders_ng/textmask.vert
index 9d80d5dadb..e0b3c01bce 100644
--- a/src/quick/scenegraph/shaders_ng/textmask.vert
+++ b/src/quick/scenegraph/shaders_ng/textmask.vert
@@ -6,7 +6,8 @@ layout(location = 1) in vec2 tCoord;
 layout(location = 0) out vec2 sampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -17,6 +18,6 @@ out gl_PerVertex { vec4 gl_Position; };
 void main()
 {
      sampleCoord = tCoord * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/util/qquickstyledtext.cpp b/src/quick/util/qquickstyledtext.cpp
index d531fc9205..a25af90414 100644
--- a/src/quick/util/qquickstyledtext.cpp
+++ b/src/quick/util/qquickstyledtext.cpp
@@ -564,6 +564,8 @@ void QQuickStyledTextPrivate::parseEntity(const QChar *&ch, const QString &textI
                 textOut += QChar(60);
             else if (entity == QLatin1String("amp"))
                 textOut += QChar(38);
+            else if (entity == QLatin1String("apos"))
+                textOut += QChar(39);
             else if (entity == QLatin1String("quot"))
                 textOut += QChar(34);
             else if (entity == QLatin1String("nbsp"))
diff --git a/src/quick/util/qquicktimeline.cpp b/src/quick/util/qquicktimeline.cpp
index 7ec7c827eb..abe6eb7261 100644
--- a/src/quick/util/qquicktimeline.cpp
+++ b/src/quick/util/qquicktimeline.cpp
@@ -53,6 +53,8 @@
 
 QT_BEGIN_NAMESPACE
 
+Q_LOGGING_CATEGORY(lcTl, "qt.quick.timeline")
+
 struct Update {
     Update(QQuickTimeLineValue *_g, qreal _v)
         : g(_g), v(_v) {}
@@ -513,6 +515,7 @@ void QQuickTimeLine::reset(QQuickTimeLineValue &timeLineValue)
         qWarning() << "QQuickTimeLine: Cannot reset a QQuickTimeLineValue owned by another timeline.";
         return;
     }
+    qCDebug(lcTl) << static_cast<QObject*>(this) << timeLineValue.value();
     remove(&timeLineValue);
     timeLineValue._t = nullptr;
 }
diff --git a/src/quickwidgets/qquickwidget.cpp b/src/quickwidgets/qquickwidget.cpp
index 39780f8de3..223d91f579 100644
--- a/src/quickwidgets/qquickwidget.cpp
+++ b/src/quickwidgets/qquickwidget.cpp
@@ -106,6 +106,7 @@ void QQuickWidgetPrivate::init(QQmlEngine* e)
 
     renderControl = new QQuickWidgetRenderControl(q);
     offscreenWindow = new QQuickWindow(*new QQuickOffcreenWindowPrivate(),renderControl);
+    offscreenWindow->setScreen(q->screen());
     offscreenWindow->setTitle(QString::fromLatin1("Offscreen"));
     offscreenWindow->setObjectName(QString::fromLatin1("QQuickOffScreenWindow"));
     // Do not call create() on offscreenWindow.
@@ -901,9 +902,7 @@ void QQuickWidgetPrivate::createContext()
 
         context = new QOpenGLContext;
         context->setFormat(offscreenWindow->requestedFormat());
-        const QWindow *win = q->window()->windowHandle();
-        if (win && win->screen())
-            context->setScreen(win->screen());
+        context->setScreen(q->screen());
         QOpenGLContext *shareContext = qt_gl_global_share_context();
         if (!shareContext)
             shareContext = QWidgetPrivate::get(q->window())->shareContext();
@@ -1520,19 +1519,16 @@ bool QQuickWidget::event(QEvent *e)
         d->handleWindowChange();
         break;
 
-    case QEvent::ScreenChangeInternal:
-        if (QWindow *window = this->window()->windowHandle()) {
-            QScreen *newScreen = window->screen();
-
-            if (d->offscreenWindow)
-                d->offscreenWindow->setScreen(newScreen);
-            if (d->offscreenSurface)
-                d->offscreenSurface->setScreen(newScreen);
+    case QEvent::ScreenChangeInternal: {
+        QScreen *newScreen = screen();
+        if (d->offscreenWindow)
+            d->offscreenWindow->setScreen(newScreen);
+        if (d->offscreenSurface)
+            d->offscreenSurface->setScreen(newScreen);
 #if QT_CONFIG(opengl)
-            if (d->context)
-                d->context->setScreen(newScreen);
+        if (d->context)
+            d->context->setScreen(newScreen);
 #endif
-        }
 
         if (d->useSoftwareRenderer
 #if QT_CONFIG(opengl)
@@ -1545,7 +1541,7 @@ bool QQuickWidget::event(QEvent *e)
             d->render(true);
         }
         break;
-
+    }
     case QEvent::Show:
     case QEvent::Move:
         d->updatePosition();
diff --git a/tests/auto/qml/qjsengine/tst_qjsengine.cpp b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
index 3b7d74df63..b75bf820d5 100644
--- a/tests/auto/qml/qjsengine/tst_qjsengine.cpp
+++ b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
@@ -102,6 +102,7 @@ private slots:
     void valueConversion_RegularExpression();
     void castWithMultipleInheritance();
     void collectGarbage();
+    void collectGarbageNestedWrappersTwoEngines();
     void gcWithNestedDataStructure();
     void stacktrace();
     void numberParsing_data();
@@ -1809,6 +1810,44 @@ void tst_QJSEngine::collectGarbage()
     QVERIFY(ptr.isNull());
 }
 
+class TestObjectContainer : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QObject *dummy MEMBER m_dummy CONSTANT)
+
+public:
+    TestObjectContainer() : m_dummy(new QObject(this)) {}
+
+private:
+    QObject *m_dummy;
+};
+
+void tst_QJSEngine::collectGarbageNestedWrappersTwoEngines()
+{
+    QJSEngine engine1;
+    QJSEngine engine2;
+
+    TestObjectContainer container;
+    QQmlEngine::setObjectOwnership(&container, QQmlEngine::CppOwnership);
+
+    engine1.globalObject().setProperty("foobar", engine1.newQObject(&container));
+    engine2.globalObject().setProperty("foobar", engine2.newQObject(&container));
+
+    engine1.evaluate("foobar.dummy.baz = 42");
+    engine2.evaluate("foobar.dummy.baz = 43");
+
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+
+    engine1.collectGarbage();
+    engine2.collectGarbage();
+
+    // The GC should not collect dummy object wrappers neither in engine1 nor engine2, we
+    // verify that by checking whether the baz property still has its previous value.
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+}
+
 void tst_QJSEngine::gcWithNestedDataStructure()
 {
     // The GC must be able to traverse deeply nested objects, otherwise this
diff --git a/tests/auto/qml/qqmldelegatemodel/data/ImageToggle.qml b/tests/auto/qml/qqmldelegatemodel/data/ImageToggle.qml
deleted file mode 100644
index fa154b25f3..0000000000
--- a/tests/auto/qml/qqmldelegatemodel/data/ImageToggle.qml
+++ /dev/null
@@ -1,21 +0,0 @@
-import QtQuick 2.0
-
-Item {
-    property var isSelected: null
-    property string source
-    implicitWidth: 16
-    implicitHeight: 16
-
-    onSourceChanged: {
-      updateImageSource()
-    }
-
-    onIsSelectedChanged: {
-      updateImageSource()
-    }
-
-    function updateImageSource() {
-     let result = isSelected ? source + "_selected_dark.png" : source + "_active_dark.png"
-    }
-
-}
diff --git a/tests/auto/qml/qqmldelegatemodel/data/contextAccessedByHandler.qml b/tests/auto/qml/qqmldelegatemodel/data/contextAccessedByHandler.qml
deleted file mode 100644
index 46d7524527..0000000000
--- a/tests/auto/qml/qqmldelegatemodel/data/contextAccessedByHandler.qml
+++ /dev/null
@@ -1,31 +0,0 @@
-import QtQuick 2.0
-
-Item {
-    id: root
-    width: 640
-    height: 480
-    property bool works: myView.currentItem.okay
-
-    ListView {
-        id: myView
-        model: myModel
-        anchors.fill: parent
-        delegate: Row {
-            property alias okay: image.isSelected
-            ImageToggle {
-                id: image
-                source: "glyph_16_arrow_patch"
-                isSelected: model.age < 6
-            }
-            Text {
-                text: "age:" + model.age + " selected:" + image.isSelected
-            }
-        }
-    }
-
-    ListModel {
-        id: myModel
-        ListElement { type: "Cat"; age: 3; }
-        ListElement { type: "Dog"; age: 2; }
-    }
-}
diff --git a/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml
new file mode 100644
index 0000000000..206133bb39
--- /dev/null
+++ b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml
@@ -0,0 +1,11 @@
+import QtQuick 2.8
+
+ListView {
+    id: root
+    width: 200
+    height: 200
+
+    delegate: Text {
+        text: display
+    }
+}
diff --git a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
index 35f1e2c94d..120b1897a1 100644
--- a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
+++ b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
@@ -27,6 +27,8 @@
 ****************************************************************************/
 
 #include <QtTest/qtest.h>
+#include <QtCore/QConcatenateTablesProxyModel>
+#include <QtGui/QStandardItemModel>
 #include <QtQml/qqmlcomponent.h>
 #include <QtQmlModels/private/qqmldelegatemodel_p.h>
 #include <QtQuick/qquickview.h>
@@ -46,7 +48,7 @@ private slots:
     void valueWithoutCallingObjectFirst();
     void filterOnGroup_removeWhenCompleted();
     void qtbug_86017();
-    void contextAccessedByHandler();
+    void redrawUponColumnChange();
 };
 
 class AbstractItemModel : public QAbstractItemModel
@@ -165,25 +167,28 @@ void tst_QQmlDelegateModel::qtbug_86017()
     QCOMPARE(model->filterGroup(), "selected");
 }
 
-void tst_QQmlDelegateModel::filterOnGroup_removeWhenCompleted()
+void tst_QQmlDelegateModel::redrawUponColumnChange()
 {
-    QQuickView view(testFileUrl("removeFromGroup.qml"));
+    QStandardItemModel m1;
+    m1.appendRow({
+            new QStandardItem("Banana"),
+            new QStandardItem("Coconut"),
+    });
+
+    QQuickView view(testFileUrl("redrawUponColumnChange.qml"));
     QCOMPARE(view.status(), QQuickView::Ready);
     view.show();
     QQuickItem *root = view.rootObject();
+    root->setProperty("model", QVariant::fromValue<QObject *>(&m1));
+
+    QObject *item = root->property("currentItem").value<QObject *>();
+    QVERIFY(item);
+    QCOMPARE(item->property("text").toString(), "Banana");
+
     QVERIFY(root);
-    QQmlDelegateModel *model = root->findChild<QQmlDelegateModel*>();
-    QVERIFY(model);
-    QVERIFY(QTest::qWaitFor([=]{ return model->count() == 2; }));
-}
+    m1.removeColumn(0);
 
-void tst_QQmlDelegateModel::contextAccessedByHandler()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine, testFileUrl("contextAccessedByHandler.qml"));
-    QScopedPointer<QObject> root(component.create());
-    QVERIFY2(root, qPrintable(component.errorString()));
-    QVERIFY(root->property("works").toBool());
+    QCOMPARE(item->property("text").toString(), "Coconut");
 }
 
 QTEST_MAIN(tst_QQmlDelegateModel)
diff --git a/tests/auto/qml/qqmlecmascript/data/generatorCallsGC.qml b/tests/auto/qml/qqmlecmascript/data/generatorCallsGC.qml
deleted file mode 100644
index 7fe366cac8..0000000000
--- a/tests/auto/qml/qqmlecmascript/data/generatorCallsGC.qml
+++ /dev/null
@@ -1,13 +0,0 @@
-import QtQml 2.15
-
-QtObject {
-  function test_generator_gc() {
-    ((function*() { gc() })()).next();
-    ((function*() { gc() })()).next();
-    ((function*() { gc() })()).next();
-    ((function*() { gc() })()).next();
-  }
-
-  Component.onCompleted: () => test_generator_gc()
-
-}
diff --git a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
index 7da1b2c500..3c3a2a7a99 100644
--- a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
+++ b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
@@ -240,7 +240,6 @@ private slots:
     void function();
     void topLevelGeneratorFunction();
     void generatorCrashNewProperty();
-    void generatorCallsGC();
     void qtbug_10696();
     void qtbug_11606();
     void qtbug_11600();
@@ -6506,15 +6505,6 @@ void tst_qqmlecmascript::generatorCrashNewProperty()
     QCOMPARE(o->property("c").toInt(), 42);
 }
 
-void tst_qqmlecmascript::generatorCallsGC()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine, testFileUrl("generatorCallsGC.qml"));
-
-    QScopedPointer<QObject> o(component.create()); // should not crash
-    QVERIFY2(o != nullptr, qPrintable(component.errorString()));
-}
-
 // Test the "Qt.include" method
 void tst_qqmlecmascript::include()
 {
diff --git a/tests/auto/qml/qqmllanguage/data/qtbug_89822.errors.txt b/tests/auto/qml/qqmllanguage/data/qtbug_89822.errors.txt
deleted file mode 100644
index d69122ef8b..0000000000
--- a/tests/auto/qml/qqmllanguage/data/qtbug_89822.errors.txt
+++ /dev/null
@@ -1 +0,0 @@
-6:40:Invalid alias target
diff --git a/tests/auto/qml/qqmllanguage/data/qtbug_89822.qml b/tests/auto/qml/qqmllanguage/data/qtbug_89822.qml
deleted file mode 100644
index 17602ca4b9..0000000000
--- a/tests/auto/qml/qqmllanguage/data/qtbug_89822.qml
+++ /dev/null
@@ -1,8 +0,0 @@
-import QtQml 2.0
-
-QtObject {
-    id: root
-    readonly property QtObject test: QtObject { property int subproperty: 3}
-    readonly property alias testAlias: root.test.subproperty
-}
-
diff --git a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
index 31bf30c57c..94ecd6862a 100644
--- a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
+++ b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
@@ -146,7 +146,6 @@ private slots:
     void aliasProperties();
     void aliasPropertiesAndSignals();
     void aliasPropertyChangeSignals();
-    void qtbug_89822();
     void componentCompositeType();
     void i18n();
     void i18n_data();
@@ -2233,12 +2232,6 @@ void tst_qqmllanguage::aliasPropertiesAndSignals()
     QCOMPARE(o->property("test").toBool(), true);
 }
 
-void tst_qqmllanguage::qtbug_89822()
-{
-    QQmlComponent component(&engine, testFileUrl("qtbug_89822.qml"));
-    VERIFY_ERRORS("qtbug_89822.errors.txt");
-}
-
 // Test that the root element in a composite type can be a Component
 void tst_qqmllanguage::componentCompositeType()
 {
diff --git a/tests/auto/qml/qqmlvaluetypes/data/matrix4x4_invokables.qml b/tests/auto/qml/qqmlvaluetypes/data/matrix4x4_invokables.qml
index 09f1d472b7..aa26956922 100644
--- a/tests/auto/qml/qqmlvaluetypes/data/matrix4x4_invokables.qml
+++ b/tests/auto/qml/qqmlvaluetypes/data/matrix4x4_invokables.qml
@@ -10,59 +10,6 @@ Item {
     property variant v2: Qt.vector3d(1,2,3)
     property real factor: 2.23
 
-    function testTransformation() {
-        let m = Qt.matrix4x4();
-
-        m.scale(1, 2, 4);
-        if (m !== Qt.matrix4x4(1, 0, 0, 0,
-                               0, 2, 0, 0,
-                               0, 0, 4, 0,
-                               0, 0, 0, 1))
-            return false;
-        m.scale(Qt.vector3d(-8, -4, -2));
-        if (m !== Qt.matrix4x4(-8, 0, 0, 0,
-                               0,-8, 0, 0,
-                               0, 0, -8, 0,
-                               0, 0, 0, 1))
-            return false;
-        m.scale(-1 / 8);
-        if (m !== Qt.matrix4x4())
-            return false;
-
-        m.rotate(180, Qt.vector3d(1, 0, 0));
-        if (m !== Qt.matrix4x4(1, 0, 0, 0,
-                               0, -1, 0, 0,
-                               0, 0, -1, 0,
-                               0, 0, 0, 1))
-            return false;
-        m.rotate(180, Qt.vector3d(0, 1, 0));
-        if (m !== Qt.matrix4x4(-1, 0, 0, 0,
-                               0, -1, 0, 0,
-                               0, 0, 1, 0,
-                               0, 0, 0, 1))
-            return false;
-        m.rotate(180, Qt.vector3d(0, 0, 1));
-        if (m !== Qt.matrix4x4())
-            return false;
-
-        m.translate(Qt.vector3d(1, 2, 4));
-        if (m !== Qt.matrix4x4(1, 0, 0, 1,
-                               0, 1, 0, 2,
-                               0, 0, 1, 4,
-                               0, 0, 0, 1))
-            return false;
-
-        m = Qt.matrix4x4();
-        m.lookAt(Qt.vector3d(1, 2, 4), Qt.vector3d(1, 2, 0), Qt.vector3d(0, 1, 0));
-        if (m !== Qt.matrix4x4(1, 0, 0, -1,
-                               0, 1, 0, -2,
-                               0, 0, 1, -4,
-                               0, 0, 0, 1))
-            return false;
-
-        return true;
-    }
-
     Component.onCompleted: {
         success = true;
         if (m1.times(m2) != Qt.matrix4x4(26, 26, 26, 26, 52, 52, 52, 52, 78, 78, 78, 78, 104, 104, 104, 104)) success = false;
@@ -80,6 +27,5 @@ Item {
         if (m1.transposed() != Qt.matrix4x4(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)) success = false;
         if (m1.fuzzyEquals(m2)) success = false;
         if (!m1.fuzzyEquals(m2, 10)) success = false;
-        if (!testTransformation()) success = false;
     }
 }
diff --git a/tests/auto/qml/qv4mm/tst_qv4mm.cpp b/tests/auto/qml/qv4mm/tst_qv4mm.cpp
index 5d635aa63b..824fd89e5b 100644
--- a/tests/auto/qml/qv4mm/tst_qv4mm.cpp
+++ b/tests/auto/qml/qv4mm/tst_qv4mm.cpp
@@ -76,10 +76,10 @@ void tst_qv4mm::multiWrappedQObjects()
         QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
         QCOMPARE(engine2.memoryManager->m_pendingFreedObjectWrapperValue.size(), 0);
 
-        // Moves the additional WeakValue from m_multiplyWrappedQObjects to
-        // m_pendingFreedObjectWrapperValue. It's still alive after all.
+        // The additional WeakValue from m_multiplyWrappedQObjects hasn't been moved
+        // to m_pendingFreedObjectWrapperValue yet. It's still alive after all.
         engine1.memoryManager->runGC();
-        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 2);
+        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
 
         // engine2 doesn't own the object as engine1 was the first to wrap it above.
         // Therefore, no effect here.
diff --git a/tests/auto/quick/nodes/tst_nodestest.cpp b/tests/auto/quick/nodes/tst_nodestest.cpp
index a4f138c8df..249ecd5aa5 100644
--- a/tests/auto/quick/nodes/tst_nodestest.cpp
+++ b/tests/auto/quick/nodes/tst_nodestest.cpp
@@ -125,12 +125,12 @@ public:
         setRootNode(root);
     }
 
-    void render() override {
+    void render() {
         ++renderCount;
         renderingOrder = ++globalRendereringOrder;
     }
 
-    void nodeChanged(QSGNode *node, QSGNode::DirtyState state) override {
+    void nodeChanged(QSGNode *node, QSGNode::DirtyState state) {
         changedNode = node;
         changedState = state;
         QSGBatchRenderer::Renderer::nodeChanged(node, state);
diff --git a/tests/auto/quick/pointerhandlers/qquickdraghandler/data/dragHandlerUnderModalLayer.qml b/tests/auto/quick/pointerhandlers/qquickdraghandler/data/dragHandlerUnderModalLayer.qml
deleted file mode 100644
index b24812c914..0000000000
--- a/tests/auto/quick/pointerhandlers/qquickdraghandler/data/dragHandlerUnderModalLayer.qml
+++ /dev/null
@@ -1,34 +0,0 @@
-import QtQuick 2.15
-
-import Test 1.0
-
-Item {
-    width: 640
-    height: 480
-
-    Rectangle {
-        anchors.fill: parent
-        color: "grey"
-
-        Rectangle {
-            x: 200
-            y: 200
-            width: 100
-            height: 100
-            color: "orange"
-            DragHandler {
-                grabPermissions: DragHandler.CanTakeOverFromAnything // but not anything with keepMouseGrab!
-            }
-        }
-    }
-
-    ModalLayer {
-        anchors.fill: parent
-
-        Rectangle {
-            anchors.fill: parent
-            color: "red"
-            opacity: 0.4
-        }
-    }
-}
diff --git a/tests/auto/quick/pointerhandlers/qquickdraghandler/tst_qquickdraghandler.cpp b/tests/auto/quick/pointerhandlers/qquickdraghandler/tst_qquickdraghandler.cpp
index f71febbaf9..4d6866041e 100644
--- a/tests/auto/quick/pointerhandlers/qquickdraghandler/tst_qquickdraghandler.cpp
+++ b/tests/auto/quick/pointerhandlers/qquickdraghandler/tst_qquickdraghandler.cpp
@@ -68,7 +68,6 @@ private slots:
     void touchPassiveGrabbers_data();
     void touchPassiveGrabbers();
     void touchPinchAndMouseMove();
-    void underModalLayer();
 
 private:
     void createView(QScopedPointer<QQuickView> &window, const char *fileName);
@@ -812,59 +811,6 @@ void tst_DragHandler::touchPinchAndMouseMove()
     }
 }
 
-class ModalLayer : public QQuickItem {
-public:
-    explicit ModalLayer(QQuickItem* parent = nullptr) : QQuickItem(parent) {
-        this->setAcceptedMouseButtons(Qt::AllButtons);
-        this->setAcceptTouchEvents(true);
-        this->setKeepMouseGrab(true);
-        this->setKeepTouchGrab(true);
-    }
-
-    bool event(QEvent* event) override {
-        switch (event->type()) {
-        case QEvent::KeyPress:
-        case QEvent::MouseMove:
-        case QEvent::MouseButtonPress:
-        case QEvent::MouseButtonRelease:
-        case QEvent::MouseTrackingChange:
-        case QEvent::MouseButtonDblClick:
-        case QEvent::Wheel:
-        case QEvent::TouchBegin:
-        case QEvent::TouchUpdate:
-        case QEvent::TouchCancel:
-        case QEvent::TouchEnd: {
-            qCDebug(lcPointerTests) << "BLOCK!" << event->type();
-            return true;
-        }
-        default: break;
-        }
-        return QQuickItem::event(event);
-    }
-};
-
-void tst_DragHandler::underModalLayer() // QTBUG-78258
-{
-    qmlRegisterType<ModalLayer>("Test", 1, 0, "ModalLayer");
-
-    const int dragThreshold = QGuiApplication::styleHints()->startDragDistance();
-    QScopedPointer<QQuickView> windowPtr;
-    createView(windowPtr, "dragHandlerUnderModalLayer.qml");
-    QQuickView * window = windowPtr.data();
-    QPointer<QQuickDragHandler> dragHandler = window->rootObject()->findChild<QQuickDragHandler*>();
-    QVERIFY(dragHandler);
-
-    QPoint p1(250, 250);
-    QTest::mousePress(window, Qt::LeftButton, Qt::NoModifier, p1);
-    p1 += QPoint(dragThreshold, dragThreshold);
-    QTest::mouseMove(window, p1);
-    QVERIFY(!dragHandler->active());
-    p1 += QPoint(dragThreshold, dragThreshold);
-    QTest::mouseMove(window, p1);
-    QVERIFY(!dragHandler->active());
-    QTest::mouseRelease(window, Qt::LeftButton);
-}
-
 QTEST_MAIN(tst_DragHandler)
 
 #include "tst_qquickdraghandler.moc"
diff --git a/tests/auto/quick/pointerhandlers/qquickpinchhandler/tst_qquickpinchhandler.cpp b/tests/auto/quick/pointerhandlers/qquickpinchhandler/tst_qquickpinchhandler.cpp
index 2b8ddd197d..19fdae3b44 100644
--- a/tests/auto/quick/pointerhandlers/qquickpinchhandler/tst_qquickpinchhandler.cpp
+++ b/tests/auto/quick/pointerhandlers/qquickpinchhandler/tst_qquickpinchhandler.cpp
@@ -217,7 +217,6 @@ void tst_QQuickPinchHandler::scale()
 
     QQuickPinchHandler *pinchHandler = window->rootObject()->findChild<QQuickPinchHandler*>("pinchHandler");
     QVERIFY(pinchHandler != nullptr);
-    QSignalSpy grabChangedSpy(pinchHandler, SIGNAL(grabChanged(QQuickEventPoint::GrabTransition, QQuickEventPoint*)));
 
     QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != nullptr);
@@ -239,7 +238,6 @@ void tst_QQuickPinchHandler::scale()
         // it is outside its bounds.
         pinchSequence.stationary(0).press(1, p1, window).commit();
         QQuickTouchUtils::flush(window);
-        QTRY_COMPARE(grabChangedSpy.count(), 1); // passive grab
 
         QPoint pd(10, 10);
         // move one point until PinchHandler activates
@@ -249,8 +247,6 @@ void tst_QQuickPinchHandler::scale()
             QQuickTouchUtils::flush(window);
         }
         QCOMPARE(pinchHandler->active(), true);
-        // first point got a passive grab; both points got exclusive grabs
-        QCOMPARE(grabChangedSpy.count(), 3);
         QLineF line(p0, p1);
         const qreal startLength = line.length();
 
diff --git a/tests/auto/quick/qquickcanvasitem/data/tst_line.qml b/tests/auto/quick/qquickcanvasitem/data/tst_line.qml
index fb4db5ae54..dc960a24d0 100644
--- a/tests/auto/quick/qquickcanvasitem/data/tst_line.qml
+++ b/tests/auto/quick/qquickcanvasitem/data/tst_line.qml
@@ -894,37 +894,6 @@ CanvasTestCase {
        comparePixel(ctx, 39,0, 0,0,0,0);
   }
 
-   function test_lineDashReset(row) {
-       var canvas = createCanvasObject(row);
-       var ctx = canvas.getContext('2d');
-       ctx.reset();
-       ctx.strokeStyle = "#ff0000";
-       ctx.lineWidth = 2;
-       var pattern = [2, 3, 5, 1, 6, 3]
-       ctx.setLineDash(pattern)
-
-       compare(ctx.getLineDash(), pattern);
-
-       pattern = []
-       ctx.setLineDash(pattern)
-       compare(ctx.getLineDash(), pattern);
-
-       ctx.beginPath();
-       ctx.moveTo(0, 0);
-       ctx.lineTo(40, 0);
-       ctx.stroke();
-
-       comparePixel(ctx, 0,0, 255,0,0,255);
-       comparePixel(ctx, 4,0, 255,0,0,255);
-       comparePixel(ctx, 5,0, 255,0,0,255);
-       comparePixel(ctx, 14,0, 255,0,0,255);
-       comparePixel(ctx, 20,0, 255,0,0,255);
-       comparePixel(ctx, 21,0, 255,0,0,255);
-       comparePixel(ctx, 22,0, 255,0,0,255);
-       comparePixel(ctx, 34,0, 255,0,0,255);
-       comparePixel(ctx, 35,0, 255,0,0,255);
-   }
-
    function test_lineDashOffset(row) {
        var canvas = createCanvasObject(row);
        var ctx = canvas.getContext('2d');
diff --git a/tests/auto/quick/qquickdesignersupport/data/RecursiveProperty.qml b/tests/auto/quick/qquickdesignersupport/data/RecursiveProperty.qml
deleted file mode 100644
index ec419f8935..0000000000
--- a/tests/auto/quick/qquickdesignersupport/data/RecursiveProperty.qml
+++ /dev/null
@@ -1,8 +0,0 @@
-import QtQuick 2.0
-
-Item {
-    id: myObject
-    readonly property int testProperty: 0
-    readonly property QtObject myproperty: myObject
-}
-
diff --git a/tests/auto/quick/qquickdesignersupport/data/propertyNameTest.qml b/tests/auto/quick/qquickdesignersupport/data/propertyNameTest.qml
deleted file mode 100644
index 88fd8509cc..0000000000
--- a/tests/auto/quick/qquickdesignersupport/data/propertyNameTest.qml
+++ /dev/null
@@ -1,13 +0,0 @@
-import QtQuick 2.11
-
-Rectangle {
-    objectName: "rootItem"
-    color: "white"
-    width: 800
-    height: 600
-
-    RecursiveProperty {
-        objectName: "recursiveProperty"
-
-    }
-}
diff --git a/tests/auto/quick/qquickdesignersupport/tst_qquickdesignersupport.cpp b/tests/auto/quick/qquickdesignersupport/tst_qquickdesignersupport.cpp
index 0471619049..b44977bd5a 100644
--- a/tests/auto/quick/qquickdesignersupport/tst_qquickdesignersupport.cpp
+++ b/tests/auto/quick/qquickdesignersupport/tst_qquickdesignersupport.cpp
@@ -62,7 +62,6 @@ private slots:
     void testNotifyPropertyChangeCallBack();
     void testFixResourcePathsForObjectCallBack();
     void testComponentOnCompleteSignal();
-    void testPropertyNames();
 };
 
 void tst_qquickdesignersupport::customData()
@@ -587,50 +586,6 @@ void tst_qquickdesignersupport::testComponentOnCompleteSignal()
     }
 }
 
-void tst_qquickdesignersupport::testPropertyNames()
-{
-#ifdef Q_CC_MINGW
-    QSKIP("QQuickDesignerSupportProperties::registerCustomData segfaults on mingw. QTBUG-90869");
-#endif
-
-    QScopedPointer<QQuickView> view(new QQuickView);
-    view->engine()->setOutputWarningsToStandardError(false);
-    view->setSource(testFileUrl("propertyNameTest.qml"));
-
-    QVERIFY(view->errors().isEmpty());
-    QQuickItem *rootItem = view->rootObject();
-    QVERIFY(rootItem);
-
-    QQuickDesignerSupport::PropertyNameList names = QQuickDesignerSupportProperties::allPropertyNames(rootItem);
-    QVERIFY(!names.isEmpty());
-    QVERIFY(names.contains("width"));
-    QVERIFY(names.contains("height"));
-    QVERIFY(names.contains("clip"));
-    QVERIFY(names.contains("opacity"));
-    QVERIFY(names.contains("childrenRect"));
-    QVERIFY(names.contains("activeFocus"));
-    QVERIFY(names.contains("border.width"));
-    names = QQuickDesignerSupportProperties::propertyNameListForWritableProperties(rootItem);
-    QVERIFY(!names.isEmpty());
-    QVERIFY(names.contains("width"));
-    QVERIFY(names.contains("height"));
-    QVERIFY(names.contains("opacity"));
-    QVERIFY(names.contains("clip"));
-    QVERIFY(!names.contains("childrenRect"));
-    QVERIFY(!names.contains("activeFocus"));
-    QVERIFY(names.contains("border.width"));
-
-    QQuickItem *recursiveProperty = findItem<QQuickItem>(rootItem, QLatin1String("recursiveProperty"));
-    QVERIFY(recursiveProperty);
-    names = QQuickDesignerSupportProperties::allPropertyNames(recursiveProperty);
-    QVERIFY(!names.isEmpty());
-    QVERIFY(names.contains("testProperty"));
-    QVERIFY(names.contains("myproperty.testProperty"));
-
-    names = QQuickDesignerSupportProperties::propertyNameListForWritableProperties(recursiveProperty);
-    QVERIFY(!names.isEmpty());
-    QVERIFY(!names.contains("testProperty"));
-}
 
 QTEST_MAIN(tst_qquickdesignersupport)
 
diff --git a/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp b/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
index f3659290eb..9fa51da6f8 100644
--- a/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
+++ b/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
@@ -870,6 +870,7 @@ void tst_qquickflickable::wheel()
     QVERIFY(flick != nullptr);
     QQuickFlickablePrivate *fp = QQuickFlickablePrivate::get(flick);
     QSignalSpy moveEndSpy(flick, SIGNAL(movementEnded()));
+    quint64 timestamp = 10;
 
     // test a vertical flick
     {
@@ -877,6 +878,7 @@ void tst_qquickflickable::wheel()
         QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(), QPoint(0,-120),
                           Qt::NoButton, Qt::NoModifier, Qt::NoScrollPhase, false);
         event.setAccepted(false);
+        event.setTimestamp(timestamp);
         QGuiApplication::sendEvent(window.data(), &event);
     }
 
@@ -887,6 +889,7 @@ void tst_qquickflickable::wheel()
     QCOMPARE(fp->velocityTimeline.isActive(), false);
     QCOMPARE(fp->timeline.isActive(), false);
     QTest::qWait(50); // make sure that onContentYChanged won't sneak in again
+    timestamp += 50;
     QCOMPARE(flick->property("movementsAfterEnd").value<int>(), 0); // QTBUG-55886
 
     // get ready to test horizontal flick
@@ -900,8 +903,8 @@ void tst_qquickflickable::wheel()
         QPoint pos(200, 200);
         QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(), QPoint(-120,0),
                           Qt::NoButton, Qt::NoModifier, Qt::NoScrollPhase, false);
-
         event.setAccepted(false);
+        event.setTimestamp(timestamp);
         QGuiApplication::sendEvent(window.data(), &event);
     }
 
@@ -926,11 +929,13 @@ void tst_qquickflickable::trackpad()
     QVERIFY(flick != nullptr);
     QSignalSpy moveEndSpy(flick, SIGNAL(movementEnded()));
     QPoint pos(200, 200);
+    quint64 timestamp = 10;
 
     {
         QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(0,-100), QPoint(0,-120),
                           Qt::NoButton, Qt::NoModifier, Qt::ScrollBegin, false);
         event.setAccepted(false);
+        event.setTimestamp(timestamp++);
         QGuiApplication::sendEvent(window.data(), &event);
     }
 
@@ -944,6 +949,7 @@ void tst_qquickflickable::trackpad()
         QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(-100,0), QPoint(-120,0),
                           Qt::NoButton, Qt::NoModifier, Qt::ScrollUpdate, false);
         event.setAccepted(false);
+        event.setTimestamp(timestamp++);
         QGuiApplication::sendEvent(window.data(), &event);
     }
 
@@ -954,6 +960,7 @@ void tst_qquickflickable::trackpad()
         QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(0,0), QPoint(0,0),
                           Qt::NoButton, Qt::NoModifier, Qt::ScrollEnd, false);
         event.setAccepted(false);
+        event.setTimestamp(timestamp++);
         QGuiApplication::sendEvent(window.data(), &event);
     }
 
diff --git a/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml b/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml
new file mode 100644
index 0000000000..889e480f3b
--- /dev/null
+++ b/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml
@@ -0,0 +1,13 @@
+import QtQuick 2.6
+
+Item {
+    visible: true
+    Item {
+        visible: false
+        Item {
+            objectName: "hiddenChild"
+            activeFocusOnTab: true
+            focus: true
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickitem2/data/focusableItemReparentedToLoadedComponent.qml b/tests/auto/quick/qquickitem2/data/focusableItemReparentedToLoadedComponent.qml
deleted file mode 100644
index a690c4243b..0000000000
--- a/tests/auto/quick/qquickitem2/data/focusableItemReparentedToLoadedComponent.qml
+++ /dev/null
@@ -1,51 +0,0 @@
-import QtQuick 2.12
-
-Item {
-    width: 240; height: 240
-    Loader {
-        id: loader
-        sourceComponent: surfaceParent
-        anchors.fill: parent
-
-        onStatusChanged: {
-            if (status === Loader.Ready) {
-                holder.create()
-                holder.item.parent = item
-            } else if (status === Loader.Null){
-                holder.item.parent = null
-            }
-        }
-    }
-
-    property var holder: QtObject {
-        property bool created: false
-        function create()
-        {
-            if (!created)
-                surfaceComponent.createObject(item)
-            created = true
-        }
-
-        property Item item: Item {
-            anchors.fill: parent
-            Component {
-                id: surfaceComponent
-                Item {
-                    anchors.fill: parent
-                    TextInput {
-                        width: parent.width
-                        font.pixelSize: 40
-                        text: "focus me"
-                    }
-                }
-            }
-        }
-    }
-
-    Component {
-        id: surfaceParent
-        Rectangle {
-            anchors.fill: parent
-        }
-    }
-}
diff --git a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
index c8f251dbe1..eeff768bb4 100644
--- a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
+++ b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
@@ -33,7 +33,6 @@
 #include <QtQuick/qquickitemgrabresult.h>
 #include <QtQuick/qquickview.h>
 #include <QtGui/private/qinputmethod_p.h>
-#include <QtQuick/private/qquickloader_p.h>
 #include <QtQuick/private/qquickrectangle_p.h>
 #include <QtQuick/private/qquicktextinput_p.h>
 #include <QtQuick/private/qquickitemchangelistener_p.h>
@@ -67,6 +66,7 @@ private slots:
     void activeFocusOnTab10();
     void activeFocusOnTab_infiniteLoop_data();
     void activeFocusOnTab_infiniteLoop();
+    void activeFocusOnTab_infiniteLoopControls();
 
     void nextItemInFocusChain();
     void nextItemInFocusChain2();
@@ -76,7 +76,6 @@ private slots:
     void qtbug_50516();
     void qtbug_50516_2_data();
     void qtbug_50516_2();
-    void focusableItemReparentedToLoadedComponent();
 
     void keys();
 #if QT_CONFIG(shortcut)
@@ -1057,6 +1056,17 @@ void tst_QQuickItem::activeFocusOnTab_infiniteLoop()
     QCOMPARE(item, window->rootObject());
 }
 
+
+void tst_QQuickItem::activeFocusOnTab_infiniteLoopControls()
+{
+    auto source = testFileUrl("activeFocusOnTab_infiniteLoop3.qml");
+    QScopedPointer<QQuickView>window(new QQuickView());
+    window->setSource(source);
+    window->show();
+    QVERIFY(window->errors().isEmpty());
+    QTest::keyClick(window.get(), Qt::Key_Tab); // should not hang
+}
+
 void tst_QQuickItem::nextItemInFocusChain()
 {
     if (!qt_tab_all_widgets())
@@ -1314,35 +1324,6 @@ void tst_QQuickItem::qtbug_50516_2()
     delete window;
 }
 
-void tst_QQuickItem::focusableItemReparentedToLoadedComponent() // QTBUG-89736
-{
-    QQuickView window;
-    window.setSource(testFileUrl("focusableItemReparentedToLoadedComponent.qml"));
-    window.show();
-    QVERIFY(QTest::qWaitForWindowActive(&window));
-    QCOMPARE(QGuiApplication::focusWindow(), &window);
-    QQuickLoader *loader = window.rootObject()->findChild<QQuickLoader *>();
-    QVERIFY(loader);
-    QTRY_VERIFY(loader->status() == QQuickLoader::Ready);
-    QQuickTextInput *textInput = window.rootObject()->findChild<QQuickTextInput *>();
-    QVERIFY(textInput);
-
-    // click to focus
-    QTest::mouseClick(&window, Qt::LeftButton, Qt::NoModifier, {10, 10});
-    QTRY_VERIFY(textInput->hasActiveFocus());
-
-    // unload and reload
-    auto component = loader->sourceComponent();
-    loader->resetSourceComponent();
-    QTRY_VERIFY(loader->status() == QQuickLoader::Null);
-    loader->setSourceComponent(component);
-    QTRY_VERIFY(loader->status() == QQuickLoader::Ready);
-
-    // click to focus again
-    QTest::mouseClick(&window, Qt::LeftButton, Qt::NoModifier, {10, 10});
-    QTRY_VERIFY(textInput->hasActiveFocus());
-}
-
 void tst_QQuickItem::keys()
 {
     QQuickView *window = new QQuickView(nullptr);
diff --git a/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml
new file mode 100644
index 0000000000..a56dcea5ad
--- /dev/null
+++ b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml
@@ -0,0 +1,10 @@
+import QtQuick 2.15
+
+Rectangle {
+    anchors.fill: parent
+    color: "blue"
+    Item {
+        Item {
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickloader/data/loader-async-race.qml b/tests/auto/quick/qquickloader/data/loader-async-race.qml
new file mode 100644
index 0000000000..8ba625c5c1
--- /dev/null
+++ b/tests/auto/quick/qquickloader/data/loader-async-race.qml
@@ -0,0 +1,14 @@
+import QtQuick 2.15
+
+Item {
+    id: root
+    Component.onCompleted: {
+        myloader.active = false
+    }
+    Loader {
+        id: myloader
+        anchors.fill: parent
+        asynchronous: true
+        source: "loader-async-race-rect.qml"
+    }
+}
diff --git a/tests/auto/quick/qquickloader/tst_qquickloader.cpp b/tests/auto/quick/qquickloader/tst_qquickloader.cpp
index 0f6c811adb..dddacbaa0b 100644
--- a/tests/auto/quick/qquickloader/tst_qquickloader.cpp
+++ b/tests/auto/quick/qquickloader/tst_qquickloader.cpp
@@ -132,6 +132,7 @@ private slots:
     void statusChangeOnlyEmittedOnce();
 
     void setSourceAndCheckStatus();
+    void asyncLoaderRace();
 };
 
 Q_DECLARE_METATYPE(QList<QQmlError>)
@@ -1496,6 +1497,24 @@ void tst_QQuickLoader::setSourceAndCheckStatus()
     QCOMPARE(loader->status(), QQuickLoader::Null);
 }
 
+void tst_QQuickLoader::asyncLoaderRace()
+{
+    QQmlApplicationEngine engine;
+    auto url = testFileUrl("loader-async-race.qml");
+    engine.load(url);
+    auto root = engine.rootObjects().at(0);
+    QVERIFY(root);
+
+    QQuickLoader *loader = root->findChild<QQuickLoader *>();
+    QCOMPARE(loader->active(), false);
+    QCOMPARE(loader->status(), QQuickLoader::Null);
+    QCOMPARE(loader->item(), nullptr);
+
+    QSignalSpy spy(loader, &QQuickLoader::itemChanged);
+    QVERIFY(!spy.wait(100));
+    QCOMPARE(loader->item(), nullptr);
+}
+
 QTEST_MAIN(tst_QQuickLoader)
 
 #include "tst_qquickloader.moc"
diff --git a/tests/auto/quick/qquicktextinput/data/focusReason.qml b/tests/auto/quick/qquicktextinput/data/focusReason.qml
deleted file mode 100644
index 7ac913d363..0000000000
--- a/tests/auto/quick/qquicktextinput/data/focusReason.qml
+++ /dev/null
@@ -1,39 +0,0 @@
-import QtQuick 2.2
-
-Rectangle {
-    width: 400
-    height: 400
-
-    Column {
-        spacing: 5
-        TextInput {
-            id: first
-            objectName: "first"
-            width: 100
-            Rectangle { anchors.fill: parent; color: parent.activeFocus ? "red" : "blue"; opacity: 0.3 }
-            KeyNavigation.backtab: third
-            KeyNavigation.tab: second
-            KeyNavigation.down: second
-        }
-        TextInput {
-            id: second
-            objectName: "second"
-            width: 100
-            Rectangle { anchors.fill: parent; color: parent.activeFocus ? "red" : "blue"; opacity: 0.3 }
-            KeyNavigation.up: first
-            KeyNavigation.backtab: first
-            KeyNavigation.tab: third
-        }
-        TextInput {
-            objectName: "third"
-            id: third
-            width: 100
-            Rectangle { anchors.fill: parent; color: parent.activeFocus ? "red" : "blue"; opacity: 0.3 }
-            KeyNavigation.backtab: second
-            KeyNavigation.tab: first
-        }
-        Component.onCompleted: {
-            first.focus = true
-        }
-    }
-}
diff --git a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
index 7c5c09055d..ac502bcb28 100644
--- a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
+++ b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
@@ -237,8 +237,6 @@ private slots:
     void QTBUG_77814_InsertRemoveNoSelection();
 
     void checkCursorDelegateWhenPaddingChanged();
-
-    void focusReason();
 private:
     void simulateKey(QWindow *, int key);
 
@@ -7086,84 +7084,6 @@ void tst_qquicktextinput::checkCursorDelegateWhenPaddingChanged()
     QCOMPARE(cursorDelegate->y(), textInput->topPadding());
 }
 
-/*!
-    Verifies that TextInput items get focus in/out events with the
-    correct focus reason set.
-
-    Up and Down keys translates to Backtab and Tab focus reasons.
-
-    See QTBUG-75862.
-*/
-void tst_qquicktextinput::focusReason()
-{
-    QQuickView view;
-    view.setSource(testFileUrl("focusReason.qml"));
-
-    QQuickTextInput *first = view.rootObject()->findChild<QQuickTextInput *>("first");
-    QQuickTextInput *second = view.rootObject()->findChild<QQuickTextInput *>("second");
-    QQuickTextInput *third = view.rootObject()->findChild<QQuickTextInput *>("third");
-    QVERIFY(first && second && third);
-
-    class FocusEventFilter : public QObject
-    {
-    public:
-        using QObject::QObject;
-
-        QHash<QObject*, Qt::FocusReason> lastFocusReason;
-    protected:
-        bool eventFilter(QObject *o, QEvent *e)
-        {
-            if (e->type() == QEvent::FocusIn || e->type() == QEvent::FocusOut) {
-                QFocusEvent *fe = static_cast<QFocusEvent*>(e);
-                lastFocusReason[o] = fe->reason();
-            }
-            return QObject::eventFilter(o, e);
-        }
-    } eventFilter;
-    first->installEventFilter(&eventFilter);
-    second->installEventFilter(&eventFilter);
-    third->installEventFilter(&eventFilter);
-
-    view.show();
-    QVERIFY(QTest::qWaitForWindowActive(&view));
-
-    QCOMPARE(qApp->focusObject(), first);
-    // on some platforms we don't get ActiveWindowFocusReason; tolerate this,
-    // it's not what we are testing in this test
-    if (eventFilter.lastFocusReason[first] != Qt::ActiveWindowFocusReason) {
-        QEXPECT_FAIL("", qPrintable(QString("No window activation event on the %1 platform")
-                                            .arg(QGuiApplication::platformName())),
-                     Continue);
-    }
-    QCOMPARE(eventFilter.lastFocusReason[first], Qt::ActiveWindowFocusReason);
-
-    QTest::mouseClick(&view, Qt::LeftButton, {},
-                      (second->boundingRect().center() + second->position()).toPoint());
-    QTRY_COMPARE(qApp->focusObject(), second);
-    QCOMPARE(eventFilter.lastFocusReason[first], Qt::MouseFocusReason);
-    QCOMPARE(eventFilter.lastFocusReason[second], Qt::MouseFocusReason);
-
-    QTest::keyClick(&view, Qt::Key_Tab);
-    QCOMPARE(qApp->focusObject(), third);
-    QCOMPARE(eventFilter.lastFocusReason[second], Qt::TabFocusReason);
-    QCOMPARE(eventFilter.lastFocusReason[third], Qt::TabFocusReason);
-
-    QTest::keyClick(&view, Qt::Key_Backtab);
-    QCOMPARE(qApp->focusObject(), second);
-    QCOMPARE(eventFilter.lastFocusReason[third], Qt::BacktabFocusReason);
-    QCOMPARE(eventFilter.lastFocusReason[second], Qt::BacktabFocusReason);
-
-    QTest::keyClick(&view, Qt::Key_Up);
-    QCOMPARE(qApp->focusObject(), first);
-    QCOMPARE(eventFilter.lastFocusReason[second], Qt::BacktabFocusReason);
-    QCOMPARE(eventFilter.lastFocusReason[first], Qt::BacktabFocusReason);
-
-    QTest::keyClick(&view, Qt::Key_Down);
-    QCOMPARE(qApp->focusObject(), second);
-    QCOMPARE(eventFilter.lastFocusReason[second], Qt::TabFocusReason);
-    QCOMPARE(eventFilter.lastFocusReason[first], Qt::TabFocusReason);
-}
-
 QTEST_MAIN(tst_qquicktextinput)
 
 #include "tst_qquicktextinput.moc"
diff --git a/tests/manual/pointer/pinchHandler.qml b/tests/manual/pointer/pinchHandler.qml
index 93169da60a..46ab91c2ed 100644
--- a/tests/manual/pointer/pinchHandler.qml
+++ b/tests/manual/pointer/pinchHandler.qml
@@ -154,14 +154,6 @@ Rectangle {
                         if (!active)
                             anim.restart(centroid.velocity)
                     }
-                    onGrabChanged: function (transition, point) {
-                        if (transition === 0x10) { // GrabExclusive
-                            console.log(point.id, "grabbed @", point.position)
-                            Qt.createQmlObject("import QtQuick 2.0; Rectangle { opacity: 0.5; border.color: 'red'; radius: 8; width: radius * 2; height: radius * 2; " +
-                                               "x: " + (point.position.x - 8) + "; y: " + (point.position.y - 8) + "}",
-                                               rect3, "touchpoint" + point.id);
-                        }
-                    }
                 }
                 TapHandler { gesturePolicy: TapHandler.DragThreshold; onTapped: rect3.z = rect2.z + 1 }
                 MomentumAnimation { id: anim; target: rect3 }
diff --git a/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml
new file mode 100644
index 0000000000..c60fc4d8b0
--- /dev/null
+++ b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml
@@ -0,0 +1,91 @@
+import QtQuick 2.0
+
+//vary font style, native rendering at non-integer offsets
+
+Item {
+    id: topLevel
+    width: 320
+    height: 580
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 100.5 + 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 200.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 300.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Rectangle {
+            y: 400.5 + 20 * index
+            x: 0.5
+            width: topLevel.width
+            height: topLevel.height
+            clip: true
+            Text {
+                renderType: Text.NativeRendering
+                width: parent.width
+                wrapMode: Text.Wrap
+                font.pointSize: 10
+                style: modelData
+                styleColor: "green"
+                text: "The quick fox jumps in style " + modelData
+            }
+        }
+    }
+}
diff --git a/tests/manual/touch/flicktext.qml b/tests/manual/touch/flicktext.qml
index 9e84261687..e69d6207a9 100644
--- a/tests/manual/touch/flicktext.qml
+++ b/tests/manual/touch/flicktext.qml
@@ -380,6 +380,36 @@ Rectangle {
                 text: "content X " + flick.contentX.toFixed(2) + " Y " + flick.contentY.toFixed(2)
             }
         }
+
+        Column {
+            Row {
+                spacing: 2
+                Examples.Button {
+                    id: decrButton
+                    text: "-"
+                    onClicked: flick.flickDeceleration -= 100
+                    Timer {
+                        running: decrButton.pressed
+                        interval: 100; repeat: true
+                        onTriggered: flick.flickDeceleration -= 100
+                    }
+                }
+                Text {
+                    horizontalAlignment: Text.AlignHCenter
+                    text: "decel:\n" + flick.flickDeceleration.toFixed(4)
+                }
+                Examples.Button {
+                    id: incrButton
+                    text: "+"
+                    onClicked: flick.flickDeceleration += 100
+                }
+                Timer {
+                    running: incrButton.pressed
+                    interval: 100; repeat: true
+                    onTriggered: flick.flickDeceleration += 100
+                }
+            }
+        }
     }
 
     Component.onCompleted: {
