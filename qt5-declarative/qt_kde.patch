diff --git a/examples/qml/doc/src/qml-extending.qdoc b/examples/qml/doc/src/qml-extending.qdoc
index 723e470d45..c9922ebd45 100644
--- a/examples/qml/doc/src/qml-extending.qdoc
+++ b/examples/qml/doc/src/qml-extending.qdoc
@@ -79,6 +79,10 @@ Qt's internal QLineEdit class.
 
 \snippet referenceexamples/extended/lineedit.h 0
 
+Note the usage of \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT.
+QML_ELEMENT uses the name of the containing type by default, "LineEditExtension" in this case.
+As the class being an extension class is an implementation detail, we choose the more natural name "LineEdit" instead
+
 The QML engine then instantiates a \l QLineEdit:
 
 \snippet referenceexamples/extended/main.cpp 1
diff --git a/src/3rdparty/masm/assembler/AssemblerBuffer.h b/src/3rdparty/masm/assembler/AssemblerBuffer.h
index 45874235b6..2292a4c244 100644
--- a/src/3rdparty/masm/assembler/AssemblerBuffer.h
+++ b/src/3rdparty/masm/assembler/AssemblerBuffer.h
@@ -140,9 +140,9 @@ namespace JSC {
             if (!result)
                 return 0;
 
-            ExecutableAllocator::makeWritable(result->start(), result->sizeInBytes());
+            ExecutableAllocator::makeWritable(result->memoryStart(), result->memorySize());
 
-            memcpy(result->start(), m_buffer, m_index);
+            memcpy(result->codeStart(), m_buffer, m_index);
             
             return result.release();
         }
diff --git a/src/3rdparty/masm/assembler/LinkBuffer.h b/src/3rdparty/masm/assembler/LinkBuffer.h
index ba57564a1d..fa669deaf9 100644
--- a/src/3rdparty/masm/assembler/LinkBuffer.h
+++ b/src/3rdparty/masm/assembler/LinkBuffer.h
@@ -333,7 +333,7 @@ inline void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::linkCode
     m_executableMemory = m_assembler->m_assembler.executableCopy(*m_globalData, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = m_executableMemory->start();
+    m_code = m_executableMemory->codeStart();
     m_size = m_assembler->m_assembler.codeSize();
     ASSERT(m_code);
 }
@@ -355,7 +355,8 @@ void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::performFinaliza
 template <typename MacroAssembler, template <typename T> class ExecutableOffsetCalculator>
 inline void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::makeExecutable()
 {
-    ExecutableAllocator::makeExecutable(code(), static_cast<int>(m_size));
+    ExecutableAllocator::makeExecutable(m_executableMemory->memoryStart(),
+                                        m_executableMemory->memorySize());
 }
 
 template <typename MacroAssembler>
@@ -442,9 +443,9 @@ inline void BranchCompactingLinkBuffer<MacroAssembler>::linkCode(void* ownerUID,
     m_executableMemory = m_globalData->executableAllocator.allocate(*m_globalData, m_initialSize, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = (uint8_t*)m_executableMemory->start();
+    m_code = (uint8_t*)m_executableMemory->codeStart();
     ASSERT(m_code);
-    ExecutableAllocator::makeWritable(m_code, m_initialSize);
+    ExecutableAllocator::makeWritable(m_executableMemory->memoryStart(), m_executableMemory->memorySize());
     uint8_t* inData = (uint8_t*)m_assembler->unlinkedCode();
     uint8_t* outData = reinterpret_cast<uint8_t*>(m_code);
     int readPtr = 0;
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
index a7e78ad78f..cde9751108 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
@@ -357,11 +357,11 @@ public:
     }
 
     MacroAssemblerCodeRef(PassRefPtr<ExecutableMemoryHandle> executableMemory)
-        : m_codePtr(executableMemory->start())
+        : m_codePtr(executableMemory->codeStart())
         , m_executableMemory(executableMemory)
     {
         ASSERT(m_executableMemory->isManaged());
-        ASSERT(m_executableMemory->start());
+        ASSERT(m_executableMemory->codeStart());
         ASSERT(m_codePtr);
     }
     
@@ -395,7 +395,7 @@ public:
     {
         if (!m_executableMemory)
             return 0;
-        return m_executableMemory->sizeInBytes();
+        return m_executableMemory->codeSize();
     }
     
     bool tryToDisassemble(const char* prefix) const
diff --git a/src/3rdparty/masm/stubs/ExecutableAllocator.h b/src/3rdparty/masm/stubs/ExecutableAllocator.h
index a439c53827..f984704023 100644
--- a/src/3rdparty/masm/stubs/ExecutableAllocator.h
+++ b/src/3rdparty/masm/stubs/ExecutableAllocator.h
@@ -82,9 +82,14 @@ struct ExecutableMemoryHandle : public RefCounted<ExecutableMemoryHandle> {
 
     inline bool isManaged() const { return true; }
 
-    void *exceptionHandler() { return m_allocation->exceptionHandler(); }
-    void *start() { return m_allocation->start(); }
-    size_t sizeInBytes() { return m_size; }
+    void *memoryStart() { return m_allocation->memoryStart(); }
+    size_t memorySize() { return m_allocation->memorySize(); }
+
+    void *exceptionHandlerStart() { return m_allocation->exceptionHandlerStart(); }
+    size_t exceptionHandlerSize() { return m_allocation->exceptionHandlerSize(); }
+
+    void *codeStart() { return m_allocation->codeStart(); }
+    size_t codeSize() { return m_size; }
 
     QV4::ExecutableAllocator::ChunkOfPages *chunk() const
     { return m_allocator->chunkForAllocation(m_allocation); }
diff --git a/src/imports/folderlistmodel/plugin.cpp b/src/imports/folderlistmodel/plugin.cpp
index 7a38769b77..7206df6664 100644
--- a/src/imports/folderlistmodel/plugin.cpp
+++ b/src/imports/folderlistmodel/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickfolderlistmodel.h"
 
 extern void qml_register_types_Qt_labs_folderlistmodel();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_folderlistmodel);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/labsanimation/plugin.cpp b/src/imports/labsanimation/plugin.cpp
index 9c985f0dcf..c35be764f9 100644
--- a/src/imports/labsanimation/plugin.cpp
+++ b/src/imports/labsanimation/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickboundaryrule_p.h"
 
 extern void qml_register_types_Qt_labs_animation();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_animation);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/labsmodels/plugin.cpp b/src/imports/labsmodels/plugin.cpp
index ab5e0023a6..b06491e663 100644
--- a/src/imports/labsmodels/plugin.cpp
+++ b/src/imports/labsmodels/plugin.cpp
@@ -51,6 +51,7 @@
 #endif
 
 extern void qml_register_types_Qt_labs_qmlmodels();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_qmlmodels);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/layouts/plugin.cpp b/src/imports/layouts/plugin.cpp
index af270c1732..b6ae516eee 100644
--- a/src/imports/layouts/plugin.cpp
+++ b/src/imports/layouts/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickstacklayout_p.h"
 
 extern void qml_register_types_QtQuick_Layouts();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Layouts);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/localstorage/plugin.cpp b/src/imports/localstorage/plugin.cpp
index e488b3d43c..0291ed4715 100644
--- a/src/imports/localstorage/plugin.cpp
+++ b/src/imports/localstorage/plugin.cpp
@@ -43,6 +43,7 @@
 #include <QtQml/qqml.h>
 
 extern void qml_register_types_QtQuick_LocalStorage();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_LocalStorage);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/settings/plugin.cpp b/src/imports/settings/plugin.cpp
index e8e640412b..e83147f612 100644
--- a/src/imports/settings/plugin.cpp
+++ b/src/imports/settings/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qqmlsettings_p.h"
 
 extern void qml_register_types_Qt_labs_settings();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_settings);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/sharedimage/plugin.cpp b/src/imports/sharedimage/plugin.cpp
index d7c2ef8d17..79168d933b 100644
--- a/src/imports/sharedimage/plugin.cpp
+++ b/src/imports/sharedimage/plugin.cpp
@@ -100,6 +100,7 @@
 */
 
 extern void qml_register_types_Qt_labs_sharedimage();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_sharedimage);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/statemachine/plugin.cpp b/src/imports/statemachine/plugin.cpp
index c370504029..abb238965e 100644
--- a/src/imports/statemachine/plugin.cpp
+++ b/src/imports/statemachine/plugin.cpp
@@ -49,6 +49,7 @@
 #include <qqml.h>
 
 extern void qml_register_types_QtQml_StateMachine();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_StateMachine);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/testlib/main.cpp b/src/imports/testlib/main.cpp
index 83fc150e6c..1da251c49b 100644
--- a/src/imports/testlib/main.cpp
+++ b/src/imports/testlib/main.cpp
@@ -51,6 +51,7 @@ QML_DECLARE_TYPE(QuickTestEvent)
 QML_DECLARE_TYPE(QuickTestUtil)
 
 extern void qml_register_types_QtTest();
+GHS_KEEP_REFERENCE(qml_register_types_QtTest);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/wavefrontmesh/plugin.cpp b/src/imports/wavefrontmesh/plugin.cpp
index eea0db19db..edd4d1dba5 100644
--- a/src/imports/wavefrontmesh/plugin.cpp
+++ b/src/imports/wavefrontmesh/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qwavefrontmesh.h"
 
 extern void qml_register_types_Qt_labs_wavefrontmesh();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_wavefrontmesh);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/window/plugin.cpp b/src/imports/window/plugin.cpp
index 5152fa02ec..ff2f10fde3 100644
--- a/src/imports/window/plugin.cpp
+++ b/src/imports/window/plugin.cpp
@@ -42,6 +42,7 @@
 #include "plugin.h"
 
 extern void qml_register_types_QtQuick_Window();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Window);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/particles/qtquickparticlesglobal_p.h b/src/particles/qtquickparticlesglobal_p.h
index 927bc29050..91c2764060 100644
--- a/src/particles/qtquickparticlesglobal_p.h
+++ b/src/particles/qtquickparticlesglobal_p.h
@@ -66,5 +66,6 @@
 #endif
 
 void Q_QUICKPARTICLES_PRIVATE_EXPORT qml_register_types_QtQuick_Particles();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Particles);
 
 #endif // QTQUICKPARTICLESGLOBAL_P_H
diff --git a/src/qml/doc/src/cppintegration/definetypes.qdoc b/src/qml/doc/src/cppintegration/definetypes.qdoc
index cbbbd9ba58..ece2fd5fd7 100644
--- a/src/qml/doc/src/cppintegration/definetypes.qdoc
+++ b/src/qml/doc/src/cppintegration/definetypes.qdoc
@@ -117,6 +117,14 @@ QML_IMPORT_NAME = com.mycompany.messaging
 QML_IMPORT_MAJOR_VERSION = 1
 \endcode
 
+If the header the class is declared in is not accessible from your project's
+include path, you may have to amend the include path so that the generated
+registration code can be compiled:
+
+\code
+INCLUDEPATH += com/mycompany/messaging
+\endcode
+
 The type can be used in an \l{qtqml-syntax-basics.html#object-declarations}
 {object declaration} from QML, and its properties can be read and written to,
 as per the example below:
diff --git a/src/qml/doc/src/qmlfunctions.qdoc b/src/qml/doc/src/qmlfunctions.qdoc
index 12b7efb159..4e531ceb61 100644
--- a/src/qml/doc/src/qmlfunctions.qdoc
+++ b/src/qml/doc/src/qmlfunctions.qdoc
@@ -250,6 +250,10 @@
   This is useful for registering types that cannot be amended to add the macros,
   for example because they belong to 3rdparty libraries.
 
+  \b{NOTE:} You may want to use \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT due to the fact that
+  the element will be named like the struct it is contained in, not the foreign type.
+  See \l {Extending QML - Extension Objects Example} for an example.
+
   \sa QML_ELEMENT, QML_NAMED_ELEMENT()
 */
 
diff --git a/src/qml/jsruntime/qv4executableallocator.cpp b/src/qml/jsruntime/qv4executableallocator.cpp
index 7ee6f39aa2..c06773d3c5 100644
--- a/src/qml/jsruntime/qv4executableallocator.cpp
+++ b/src/qml/jsruntime/qv4executableallocator.cpp
@@ -45,12 +45,22 @@
 
 using namespace QV4;
 
-void *ExecutableAllocator::Allocation::exceptionHandler() const
+void *ExecutableAllocator::Allocation::exceptionHandlerStart() const
 {
     return reinterpret_cast<void*>(addr);
 }
 
-void *ExecutableAllocator::Allocation::start() const
+size_t ExecutableAllocator::Allocation::exceptionHandlerSize() const
+{
+    return QV4::exceptionHandlerSize();
+}
+
+void *ExecutableAllocator::Allocation::memoryStart() const
+{
+    return reinterpret_cast<void*>(addr);
+}
+
+void *ExecutableAllocator::Allocation::codeStart() const
 {
     return reinterpret_cast<void*>(addr + exceptionHandlerSize());
 }
diff --git a/src/qml/jsruntime/qv4executableallocator_p.h b/src/qml/jsruntime/qv4executableallocator_p.h
index f98f2c7d33..4735fb151f 100644
--- a/src/qml/jsruntime/qv4executableallocator_p.h
+++ b/src/qml/jsruntime/qv4executableallocator_p.h
@@ -86,8 +86,14 @@ public:
             , free(true)
         {}
 
-        void *exceptionHandler() const;
-        void *start() const;
+        void *memoryStart() const;
+        size_t memorySize() const { return size; }
+
+        void *exceptionHandlerStart() const;
+        size_t exceptionHandlerSize() const;
+
+        void *codeStart() const;
+
         void invalidate() { addr = 0; }
         bool isValid() const { return addr != 0; }
         void deallocate(ExecutableAllocator *allocator);
diff --git a/src/qml/jsruntime/qv4functiontable_win64.cpp b/src/qml/jsruntime/qv4functiontable_win64.cpp
index fc13dc2602..0cb98641cd 100644
--- a/src/qml/jsruntime/qv4functiontable_win64.cpp
+++ b/src/qml/jsruntime/qv4functiontable_win64.cpp
@@ -106,7 +106,7 @@ struct ExceptionHandlerRecord
 void generateFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
 
     record->info.Version             = 1;
     record->info.Flags               = 0;
@@ -136,7 +136,7 @@ void generateFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 void destroyFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
     if (!RtlDeleteFunctionTable(&record->handler)) {
         const unsigned int errorCode = GetLastError();
         qWarning() << "Failed to remove win64 unwind hook. Error code:" << errorCode;
diff --git a/src/qml/jsruntime/qv4proxy.cpp b/src/qml/jsruntime/qv4proxy.cpp
index 24676ffd00..8bfc9fc3ba 100644
--- a/src/qml/jsruntime/qv4proxy.cpp
+++ b/src/qml/jsruntime/qv4proxy.cpp
@@ -265,9 +265,9 @@ PropertyAttributes ProxyObject::virtualGetOwnProperty(const Managed *m, Property
     ScopedProperty targetDesc(scope);
     PropertyAttributes targetAttributes = target->getOwnProperty(id, targetDesc);
     if (trapResult->isUndefined()) {
-        p->value = Encode::undefined();
-        if (targetAttributes == Attr_Invalid) {
+        if (p)
             p->value = Encode::undefined();
+        if (targetAttributes == Attr_Invalid) {
             return Attr_Invalid;
         }
         if (!targetAttributes.isConfigurable() || !target->isExtensible()) {
@@ -295,8 +295,10 @@ PropertyAttributes ProxyObject::virtualGetOwnProperty(const Managed *m, Property
         }
     }
 
-    p->value = resultDesc->value;
-    p->set = resultDesc->set;
+    if (p) {
+        p->value = resultDesc->value;
+        p->set = resultDesc->set;
+    }
     return resultAttributes;
 }
 
@@ -622,8 +624,10 @@ OwnPropertyKeyIterator *ProxyObject::virtualOwnPropertyKeys(const Object *m, Val
         else
             targetNonConfigurableKeys->push_back(keyAsValue);
     }
-    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0)
+    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     ScopedArrayObject uncheckedResultKeys(scope, scope.engine->newArrayObject());
     uncheckedResultKeys->copyArrayData(trapKeys);
@@ -637,8 +641,10 @@ OwnPropertyKeyIterator *ProxyObject::virtualOwnPropertyKeys(const Object *m, Val
         }
     }
 
-    if (target->isExtensible())
+    if (target->isExtensible()) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     len = targetConfigurableKeys->getLength();
     for (uint i = 0; i < len; ++i) {
diff --git a/src/qml/jsruntime/qv4qmlcontext.cpp b/src/qml/jsruntime/qv4qmlcontext.cpp
index e2d3b98ff6..6eece147a6 100644
--- a/src/qml/jsruntime/qv4qmlcontext.cpp
+++ b/src/qml/jsruntime/qv4qmlcontext.cpp
@@ -466,9 +466,9 @@ ReturnedValue QQmlContextWrapper::resolveQmlContextPropertyLookupGetter(Lookup *
                 return static_cast<Heap::CallContext *>(ctx)->locals[index].asReturnedValue();
         }
 
-        // Skip only block contexts within the current call context.
+        // Skip only block and call contexts.
         // Other contexts need a regular QML property lookup. See below.
-        if (ctx->type != Heap::ExecutionContext::Type_BlockContext)
+        if (ctx->type != Heap::ExecutionContext::Type_BlockContext && ctx->type != Heap::ExecutionContext::Type_CallContext)
             break;
     }
 
diff --git a/src/qml/qml/qqmlextensionplugin.h b/src/qml/qml/qqmlextensionplugin.h
index ef7ff422cd..afb3f99c4a 100644
--- a/src/qml/qml/qqmlextensionplugin.h
+++ b/src/qml/qml/qqmlextensionplugin.h
@@ -44,6 +44,13 @@
 #include <QtCore/QUrl>
 #include <QtQml/qqmlextensioninterface.h>
 
+#if defined(Q_CC_GHS)
+#  define GHS_PRAGMA(S) _Pragma(#S)
+#  define GHS_KEEP_REFERENCE(S) GHS_PRAGMA(ghs reference S ##__Fv)
+#else
+#  define GHS_KEEP_REFERENCE(S)
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QQmlEngine;
diff --git a/src/qml/qml/qqmlpropertycachecreator.cpp b/src/qml/qml/qqmlpropertycachecreator.cpp
index 36581bda4e..88d80d88ab 100644
--- a/src/qml/qml/qqmlpropertycachecreator.cpp
+++ b/src/qml/qml/qqmlpropertycachecreator.cpp
@@ -90,6 +90,15 @@ QByteArray QQmlPropertyCacheCreatorBase::createClassNameTypeByUrl(const QUrl &ur
             QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
 }
 
+QByteArray QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(const QUrl &baseUrl, int icId)
+{
+    QByteArray baseName = createClassNameTypeByUrl(baseUrl);
+    if (baseName.isEmpty())
+        baseName = QByteArray("ANON_QML_IC_") + QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
+    baseName += "_" + QByteArray::number(icId);
+    return baseName;
+}
+
 QQmlBindingInstantiationContext::QQmlBindingInstantiationContext(int referencingObjectIndex, const QV4::CompiledData::Binding *instantiatingBinding,
                                                                  const QString &instantiatingPropertyName, QQmlPropertyCache *referencingObjectPropertyCache)
     : referencingObjectIndex(referencingObjectIndex)
diff --git a/src/qml/qml/qqmlpropertycachecreator_p.h b/src/qml/qml/qqmlpropertycachecreator_p.h
index 6b02d6fb98..77e3763a49 100644
--- a/src/qml/qml/qqmlpropertycachecreator_p.h
+++ b/src/qml/qml/qqmlpropertycachecreator_p.h
@@ -104,6 +104,8 @@ public:
     static int metaTypeForPropertyType(QV4::CompiledData::BuiltinType type);
 
     static QByteArray createClassNameTypeByUrl(const QUrl &url);
+
+    static QByteArray createClassNameForInlineComponent(const QUrl &baseUrl, int icId);
 };
 
 template <typename ObjectContainer>
diff --git a/src/qml/qml/qqmlpropertyvalidator.cpp b/src/qml/qml/qqmlpropertyvalidator.cpp
index 3587609301..3a1f33113f 100644
--- a/src/qml/qml/qqmlpropertyvalidator.cpp
+++ b/src/qml/qml/qqmlpropertyvalidator.cpp
@@ -651,6 +651,19 @@ bool QQmlPropertyValidator::canCoerce(int to, QQmlPropertyCache *fromMo) const
 {
     QQmlPropertyCache *toMo = enginePrivate->rawPropertyCacheForType(to);
 
+    if (toMo == nullptr) {
+        // if we have an inline component from the current file,
+        // it is not properly registered at this point, as registration
+        // only occurs after the whole file has been validated
+        // Therefore we need to check the ICs here
+        for (const auto& icDatum : compilationUnit->inlineComponentData) {
+            if (icDatum.typeIds.id == to) {
+                toMo = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                break;
+            }
+        }
+    }
+
     while (fromMo) {
         if (fromMo == toMo)
             return true;
@@ -746,6 +759,18 @@ QQmlError QQmlPropertyValidator::validateObjectBinding(QQmlPropertyData *propert
         // effect the properties on the type, but don't effect assignability
         // Using -1 for the minor version ensures that we get the raw metaObject.
         QQmlPropertyCache *propertyMetaObject = enginePrivate->rawPropertyCacheForType(propType, -1);
+        if (!propertyMetaObject) {
+            // if we have an inline component from the current file,
+            // it is not properly registered at this point, as registration
+            // only occurs after the whole file has been validated
+            // Therefore we need to check the ICs here
+            for (const auto& icDatum: compilationUnit->inlineComponentData) {
+                if (icDatum.typeIds.id == property->propType()) {
+                    propertyMetaObject = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                    break;
+                }
+            }
+        }
 
         if (propertyMetaObject) {
             // Will be true if the assigned type inherits propertyMetaObject
diff --git a/src/qml/qml/qqmltypedata.cpp b/src/qml/qml/qqmltypedata.cpp
index fc1d0cfbcf..92a90ea677 100644
--- a/src/qml/qml/qqmltypedata.cpp
+++ b/src/qml/qml/qqmltypedata.cpp
@@ -283,9 +283,7 @@ void setupICs(const ObjectContainer &container, QHash<int, InlineComponentData>
     for (int i = 0; i != container->objectCount(); ++i) {
         auto root = container->objectAt(i);
         for (auto it = root->inlineComponentsBegin(); it != root->inlineComponentsEnd(); ++it) {
-            auto url = finalUrl;
-            url.setFragment(QString::number(it->objectIndex));
-            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameTypeByUrl(url);
+            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(finalUrl, it->objectIndex);
             InlineComponentData icDatum(QQmlMetaType::registerInternalCompositeType(className), int(it->objectIndex), int(it->nameIndex), 0, 0, 0);
             icData->insert(it->objectIndex, icDatum);
         }
diff --git a/src/qml/qtqmlglobal_p.h b/src/qml/qtqmlglobal_p.h
index a729729b67..7b0910fa13 100644
--- a/src/qml/qtqmlglobal_p.h
+++ b/src/qml/qtqmlglobal_p.h
@@ -53,6 +53,7 @@
 
 #include <QtCore/private/qglobal_p.h>
 #include <QtQml/qtqmlglobal.h>
+#include <QtQml/qqmlextensionplugin.h>
 #ifndef QT_QML_BOOTSTRAPPED
 #  include <QtQml/private/qtqml-config_p.h>
 #endif
@@ -61,6 +62,7 @@
 #define Q_QML_PRIVATE_EXPORT Q_QML_EXPORT
 
 void Q_QML_PRIVATE_EXPORT qml_register_types_QtQml();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml);
 
 #if !defined(QT_QMLDEVTOOLS_LIB) && !defined(QT_BUILD_QMLDEVTOOLS_LIB)
 #  define Q_QML_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
diff --git a/src/qmldebug/qqmlprofilerevent_p.h b/src/qmldebug/qqmlprofilerevent_p.h
index a7e37d1964..01b2f58f16 100644
--- a/src/qmldebug/qqmlprofilerevent_p.h
+++ b/src/qmldebug/qqmlprofilerevent_p.h
@@ -48,6 +48,7 @@
 #include <QtCore/qmetatype.h>
 
 #include <initializer_list>
+#include <limits>
 #include <type_traits>
 
 //
diff --git a/src/qmlmodels/qqmldelegatemodel.cpp b/src/qmlmodels/qqmldelegatemodel.cpp
index 725b9e8bc3..12c3d11937 100644
--- a/src/qmlmodels/qqmldelegatemodel.cpp
+++ b/src/qmlmodels/qqmldelegatemodel.cpp
@@ -1,6 +1,6 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2020 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the QtQml module of the Qt Toolkit.
@@ -2379,6 +2379,15 @@ void QQmlDelegateModelItem::destroyObject()
         data->ownContext = nullptr;
         data->context = nullptr;
     }
+    /* QTBUG-87228: when destroying object at the application exit, the deferred
+     * parent by setting it to QCoreApplication instance if it's nullptr, so
+     * deletion won't work. Not to leak memory, make sure our object has a that
+     * the parent claims the object at the end of the lifetime. When not at the
+     * application exit, normal event loop will handle the deferred deletion
+     * earlier.
+     */
+    if (object->parent() == nullptr)
+        object->setParent(QCoreApplication::instance());
     object->deleteLater();
 
     if (attached) {
diff --git a/src/qmlmodels/qqmllistmodel.cpp b/src/qmlmodels/qqmllistmodel.cpp
index e07951cab3..8830e08097 100644
--- a/src/qmlmodels/qqmllistmodel.cpp
+++ b/src/qmlmodels/qqmllistmodel.cpp
@@ -703,7 +703,7 @@ void ListModel::set(int elementIndex, QV4::Object *object, ListModel::SetElement
         } else if (propertyValue->isNullOrUndefined()) {
             if (reason == SetElement::WasJustInserted) {
                 QQmlError err;
-                auto memberName = propertyName->toString(m_modelCache->engine())->toQString();
+                auto memberName = propertyName->toString(v4)->toQString();
                 err.setDescription(QString::fromLatin1("%1 is %2. Adding an object with a %2 member does not create a role for it.").arg(memberName, propertyValue->isNull() ? QLatin1String("null") : QLatin1String("undefined")));
                 qmlWarning(nullptr, err);
             } else {
diff --git a/src/qmlmodels/qtqmlmodelsglobal_p.h b/src/qmlmodels/qtqmlmodelsglobal_p.h
index 1a1157138d..24df6ef7b3 100644
--- a/src/qmlmodels/qtqmlmodelsglobal_p.h
+++ b/src/qmlmodels/qtqmlmodelsglobal_p.h
@@ -59,5 +59,6 @@
 #define Q_QMLMODELS_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLMODELS_PRIVATE_EXPORT qml_register_types_QtQml_Models();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_Models);
 
 #endif // QTQMLMODELSGLOBAL_P_H
diff --git a/src/qmltyperegistrar/qmltypes.prf b/src/qmltyperegistrar/qmltypes.prf
index 354fa1736f..2cc0027b7e 100644
--- a/src/qmltyperegistrar/qmltypes.prf
+++ b/src/qmltyperegistrar/qmltypes.prf
@@ -44,7 +44,8 @@ qt_module_deps = $$replace(qt_module_deps, _private$, '')
 qt_module_deps = $$unique(qt_module_deps)
 
 for(dep, qt_module_deps) {
-    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))_metatypes.json
+    android:ABI = _$${ANDROID_TARGET_ARCH}
+    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))$${ABI}_metatypes.json
     INSTALLED_METATYPES = $$[QT_INSTALL_LIBS]/metatypes/$$METATYPES_FILENAME
     isEmpty(MODULE_BASE_OUTDIR) {
         QML_FOREIGN_METATYPES += $$INSTALLED_METATYPES
diff --git a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
index c75d5f3129..6452567f6b 100644
--- a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
+++ b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
@@ -58,5 +58,6 @@
 #define Q_QMLWORKERSCRIPT_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLWORKERSCRIPT_PRIVATE_EXPORT qml_register_types_QtQml_WorkerScript();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_WorkerScript);
 
 #endif // QTQMLWORKERSCRIPTGLOBAL_P_H
diff --git a/src/quick/designer/qquickdesignersupportproperties.cpp b/src/quick/designer/qquickdesignersupportproperties.cpp
index 335795acf1..fb6a5fb324 100644
--- a/src/quick/designer/qquickdesignersupportproperties.cpp
+++ b/src/quick/designer/qquickdesignersupportproperties.cpp
@@ -137,11 +137,8 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::propert
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
     for (int index = 0; index < metaObject->propertyCount(); ++index) {
@@ -194,12 +191,8 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allProp
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
-
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
 
diff --git a/src/quick/doc/snippets/qquickview-ex.cpp b/src/quick/doc/snippets/qquickview-ex.cpp
index 32406f8f2f..5f93dfdbe8 100644
--- a/src/quick/doc/snippets/qquickview-ex.cpp
+++ b/src/quick/doc/snippets/qquickview-ex.cpp
@@ -59,3 +59,12 @@ int main(int argc, char *argv[])
     return app.exec();
 }
 //![0]
+
+void makeDocTeamHappyByKeepingExampleCompilable() {
+//![1]
+    QScopedPointer<QQuickView> view { new QQuickView };
+    view->setInitialProperties({"x, 100"}, {"width", 50});
+    view->setSource(QUrl::fromLocalFile("myqmlfile.qml"));
+    view->show();
+//![1]
+}
diff --git a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
index 67c4611d9e..e02df00595 100644
--- a/src/quick/items/qquickitem.cpp
+++ b/src/quick/items/qquickitem.cpp
@@ -1,9 +1,9 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2021 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
-** This file is part of the QtQuick module of the Qt Toolkit.
+** This file is part of the QtQuick module of the Qt Toolkit.fset
 **
 ** $QT_BEGIN_LICENSE:LGPL$
 ** Commercial License Usage
@@ -1883,7 +1883,23 @@ void QQuickItemPrivate::updateSubFocusItem(QQuickItem *scope, bool focus)
     \endqml
 
 
-    \section2 Key Handling
+    \section2 Event Handling
+
+    All Item-based visual types can use \l {Qt Quick Input Handlers}{Input Handlers}
+    to handle incoming input events (subclasses of QInputEvent), such as mouse,
+    touch and key events. This is the preferred declarative way to handle events.
+
+    An alternative way to handle touch events is to subclass QQuickItem, call
+    setAcceptTouchEvents() in the constructor, and override touchEvent().
+    \l {QEvent::setAccepted()}{Accept} the entire event to stop delivery to
+    items underneath, and to exclusively grab all the event's touch points.
+
+    Likewise, a QQuickItem subclass can call setAcceptedMouseButtons()
+    to register to receive mouse button events, setAcceptHoverEvents()
+    to receive hover events (mouse movements while no button is pressed),
+    and override the virtual functions mousePressEvent(), mouseMoveEvent(), and
+    mouseReleaseEvent(). Those can also accept the event to prevent further
+    delivery and get an implicit grab at the same time.
 
     Key handling is available to all Item-based visual types via the \l Keys
     attached property.  The \e Keys attached property provides basic signals
@@ -3753,6 +3769,14 @@ void QQuickItem::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeo
         emit widthChanged();
     if (change.heightChange())
         emit heightChanged();
+#if QT_CONFIG(accessibility)
+    if (QAccessible::isActive()) {
+        if (QObject *acc = QQuickAccessibleAttached::findAccessible(this)) {
+            QAccessibleEvent ev(acc, QAccessible::LocationChanged);
+            QAccessible::updateAccessibility(&ev);
+        }
+    }
+#endif
 }
 
 /*!
@@ -7293,7 +7317,9 @@ bool QQuickItem::isAncestorOf(const QQuickItem *child) const
     If an item does not accept the mouse button for a particular mouse event,
     the mouse event will not be delivered to the item and will be delivered
     to the next item in the item hierarchy instead.
-  */
+
+    \sa acceptTouchEvents()
+*/
 Qt::MouseButtons QQuickItem::acceptedMouseButtons() const
 {
     Q_D(const QQuickItem);
@@ -7302,7 +7328,13 @@ Qt::MouseButtons QQuickItem::acceptedMouseButtons() const
 
 /*!
     Sets the mouse buttons accepted by this item to \a buttons.
-  */
+
+    \note In Qt 5, calling setAcceptedMouseButtons() implicitly caused
+    an item to receive touch events as well as mouse events; but it was
+    recommended to call setAcceptTouchEvents() to subscribe for them.
+    In Qt 6, it is necessary to call setAcceptTouchEvents() to continue
+    to receive them.
+*/
 void QQuickItem::setAcceptedMouseButtons(Qt::MouseButtons buttons)
 {
     Q_D(QQuickItem);
diff --git a/src/quick/items/qquicktableview.cpp b/src/quick/items/qquicktableview.cpp
index 7b73fcb393..1349d308d7 100644
--- a/src/quick/items/qquicktableview.cpp
+++ b/src/quick/items/qquicktableview.cpp
@@ -1760,11 +1760,8 @@ void QQuickTableViewPrivate::calculateTopLeft(QPoint &topLeftCell, QPointF &topL
         const auto syncView_d = syncView->d_func();
 
         if (syncView_d->loadedItems.isEmpty()) {
-            // The sync view contains no loaded items. This probably means
-            // that it has not been rebuilt yet. Which also means that
-            // we cannot rebuild anything before this happens.
-            topLeftCell.rx() = kEdgeIndexNotSet;
-            topLeftCell.ry() = kEdgeIndexNotSet;
+            topLeftCell.rx() = 0;
+            topLeftCell.ry() = 0;
             return;
         }
 
diff --git a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
index 90469ee82b..4ddd2a41bc 100644
--- a/src/quick/items/qquicktext.cpp
+++ b/src/quick/items/qquicktext.cpp
@@ -398,6 +398,8 @@ void QQuickTextPrivate::updateSize()
         layedOutTextRect = QRectF(0, 0, 0, fontHeight);
         advance = QSizeF();
         signalSizeChange(previousSize);
+        lineCount = 1;
+        emit q->lineCountChanged();
         updateType = UpdatePaintNode;
         q->update();
         return;
@@ -2166,7 +2168,7 @@ void QQuickText::resetMaximumLineCount()
     <img src="" align="top,middle,bottom" width="" height=""> - inline images
     <ol type="">, <ul type=""> and <li> - ordered and unordered lists
     <pre></pre> - preformatted
-    &gt; &lt; &amp;
+    &gt; &lt; &amp; &quot; &nbsp; &apos;
     \endcode
 
     \c Text.StyledText parser is strict, requiring tags to be correctly nested.
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index 6275b298ed..bb78ead0e8 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -3831,8 +3831,7 @@ void QQuickTextInputPrivate::parseInputMask(const QString &maskFields)
     int delimiter = maskFields.indexOf(QLatin1Char(';'));
     if (maskFields.isEmpty() || delimiter == 0) {
         if (m_maskData) {
-            delete [] m_maskData;
-            m_maskData = nullptr;
+            m_maskData.reset(nullptr);
             m_maxLength = 32767;
             internalSetText(QString());
         }
@@ -3863,8 +3862,7 @@ void QQuickTextInputPrivate::parseInputMask(const QString &maskFields)
             m_maxLength++;
     }
 
-    delete [] m_maskData;
-    m_maskData = new MaskInputData[m_maxLength];
+    m_maskData.reset(new MaskInputData[m_maxLength]);
 
     MaskInputData::Casemode m = MaskInputData::NoCaseMode;
     c = 0;
diff --git a/src/quick/items/qquicktextinput_p_p.h b/src/quick/items/qquicktextinput_p_p.h
index 7965f3d3f4..7fbba49405 100644
--- a/src/quick/items/qquicktextinput_p_p.h
+++ b/src/quick/items/qquicktextinput_p_p.h
@@ -58,6 +58,8 @@
 
 #include "qplatformdefs.h"
 
+#include <memory>
+
 //
 //  W A R N I N G
 //  -------------
@@ -230,7 +232,7 @@ public:
 
     QQuickItem *cursorItem;
     QQuickTextNode *textNode;
-    MaskInputData *m_maskData;
+    std::unique_ptr<MaskInputData[]> m_maskData;
     QInputControl *m_inputControl;
 
     QList<int> m_transactions;
diff --git a/src/quick/items/qquickview.cpp b/src/quick/items/qquickview.cpp
index 97f6689d8a..b3a5270e9b 100644
--- a/src/quick/items/qquickview.cpp
+++ b/src/quick/items/qquickview.cpp
@@ -240,7 +240,11 @@ void QQuickView::setSource(const QUrl& url)
    Sets the initial properties \a initialProperties with which the QML
    component gets initialized after calling \l QQuickView::setSource().
 
+   \snippet qquickview-ex.cpp 1
+
    \note You can only use this function to initialize top-level properties.
+   \note This function should always be called before setSource, as it has
+   no effect once the component has become \c Ready.
 
    \sa QQmlComponent::createWithInitialProperties()
    \since 5.14
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index d0c9ad5454..9ff91eb9a0 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -2864,6 +2864,14 @@ void QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QQuickPo
 {
     Q_Q(QQuickWindow);
     QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+#if defined(Q_OS_ANDROID) && QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    // QTBUG-85379
+    // In QT_VERSION below 6.0.0 touchEnabled for QtQuickItems is set by default to true
+    // It causes delivering touch events to Items which are not interested
+    // In some cases (like using Material Style in Android) it may cause a crash
+    if (itemPrivate->wasDeleted)
+        return;
+#endif
     pointerEvent->localize(item);
 
     // Let the Item's handlers (if any) have the event first.
diff --git a/src/quick/qtquickglobal_p.h b/src/quick/qtquickglobal_p.h
index 80e59563c7..97680569e7 100644
--- a/src/quick/qtquickglobal_p.h
+++ b/src/quick/qtquickglobal_p.h
@@ -62,6 +62,7 @@
 #define Q_QUICK_PRIVATE_EXPORT Q_QUICK_EXPORT
 
 void Q_QUICK_PRIVATE_EXPORT qml_register_types_QtQuick();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/quick/util/qquickstyledtext.cpp b/src/quick/util/qquickstyledtext.cpp
index 660852ba83..a25af90414 100644
--- a/src/quick/util/qquickstyledtext.cpp
+++ b/src/quick/util/qquickstyledtext.cpp
@@ -46,6 +46,8 @@
 #include "qquickstyledtext_p.h"
 #include <QQmlContext>
 
+Q_LOGGING_CATEGORY(lcStyledText, "qt.quick.styledtext")
+
 /*
     QQuickStyledText supports few tags:
 
@@ -562,10 +564,14 @@ void QQuickStyledTextPrivate::parseEntity(const QChar *&ch, const QString &textI
                 textOut += QChar(60);
             else if (entity == QLatin1String("amp"))
                 textOut += QChar(38);
+            else if (entity == QLatin1String("apos"))
+                textOut += QChar(39);
             else if (entity == QLatin1String("quot"))
                 textOut += QChar(34);
             else if (entity == QLatin1String("nbsp"))
                 textOut += QChar(QChar::Nbsp);
+            else
+                qCWarning(lcStyledText) << "StyledText doesn't support entity" << entity;
             return;
         } else if (*ch == QLatin1Char(' ')) {
             QStringRef entity(&textIn, entityStart - 1, entityLength + 1);
diff --git a/src/quickshapes/qquickshapesglobal_p.h b/src/quickshapes/qquickshapesglobal_p.h
index 40f6cfbdcf..37386c23b2 100644
--- a/src/quickshapes/qquickshapesglobal_p.h
+++ b/src/quickshapes/qquickshapesglobal_p.h
@@ -51,6 +51,7 @@
 // We mean it.
 //
 
+#include <QtQml/qqmlextensionplugin.h>
 #include "qquickshapesglobal.h"
 
 QT_BEGIN_NAMESPACE
@@ -60,5 +61,6 @@ QT_BEGIN_NAMESPACE
 QT_END_NAMESPACE
 
 void Q_QUICKSHAPES_PRIVATE_EXPORT qml_register_types_QtQuick_Shapes();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Shapes);
 
 #endif // QQUICKSHAPESGLOBAL_P_H
diff --git a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
index 84f5eebd10..e3cbeb9891 100644
--- a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
+++ b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
@@ -910,19 +910,25 @@ void tst_qv4debugger::signalParameters()
     component.setData("import QtQml 2.12\n"
                       "QtObject {\n"
                       "    id: root\n"
-                      "    property string result\n"
+                      "    property string result: 'unset'\n"
+                      "    property string resultCallbackInternal: 'unset'\n"
+                      "    property string resultCallbackExternal: 'unset'\n"
                       "    signal signalWithArg(string textArg)\n"
+                      "    function call(callback) { callback(); }\n"
+                      "    function externalCallback() { root.resultCallbackExternal = textArg; }\n"
                       "    property Connections connections : Connections {\n"
                       "        target: root\n"
-                      "        onSignalWithArg: { root.result = textArg; }\n"
+                      "        onSignalWithArg: { root.result = textArg; call(function() { root.resultCallbackInternal = textArg; }); call(externalCallback); }\n"
                       "    }\n"
                       "    Component.onCompleted: signalWithArg('something')\n"
                       "}", QUrl("test.qml"));
 
-    QVERIFY(component.isReady());
+    QVERIFY2(component.isReady(), qPrintable(component.errorString()));
     QScopedPointer<QObject> obj(component.create());
     QVERIFY(obj);
     QCOMPARE(obj->property("result").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackInternal").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackExternal").toString(), QLatin1String("unset"));
 }
 
 QTEST_MAIN(tst_qv4debugger)
diff --git a/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml
new file mode 100644
index 0000000000..affba7d9f1
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml
@@ -0,0 +1,29 @@
+import QtQml 2
+
+QtObject {
+  id: root
+  property int sum
+  Component.onCompleted: {
+    const target = { prop1: 1, prop2: 2, prop3: 3 };
+    const handler = {
+      get: function(target, key) {
+        return target[key]+1;
+      },
+      ownKeys: function() {
+        return ["prop1", "prop3"];
+      },
+      getOwnPropertyDescriptor: function(target, key) {
+        return {
+          value: this.get(target, key),
+          enumerable: true,
+          configurable: true
+        };
+      }
+    };
+    const proxy = new Proxy(target, handler);
+    for (var prop in proxy) {
+      root.sum += proxy[prop] // prop2 gets skipped, the values of 1 and 3 get incremented
+    }
+    // so root.sum should be 6 now
+  }
+}
diff --git a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
index 1e10841430..9198d3bebf 100644
--- a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
+++ b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
@@ -382,7 +382,8 @@ private slots:
     void semicolonAfterProperty();
     void hugeStack();
     void variantConversionMethod();
-
+    void proxyIteration();
+    void proxyHandlerTraps();
     void gcCrashRegressionTest();
 
 private:
@@ -9306,6 +9307,44 @@ void tst_qqmlecmascript::variantConversionMethod()
     QCOMPARE(obj.funcCalled, QLatin1String("QModelIndex"));
 }
 
+void tst_qqmlecmascript::proxyIteration()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("proxyIteration.qml"));
+    QScopedPointer<QObject> root(component.create());
+    QVERIFY2(root != nullptr, qPrintable(component.errorString()));
+    QCOMPARE(root->property("sum").toInt(), 6);
+}
+
+void tst_qqmlecmascript::proxyHandlerTraps()
+{
+    const QString expression = QStringLiteral(R"SNIPPET(
+        (function(){
+            const target = {
+                prop: 47
+            };
+            const handler = {
+                getOwnPropertyDescriptor(target, prop) {
+                    return { configurable: true, enumerable: true, value: 47 };
+                }
+            };
+            const proxy = new Proxy(target, handler);
+
+            // QTBUG-88786
+            if (!proxy.propertyIsEnumerable("prop"))
+                throw Error("FAIL: propertyisEnumerable");
+            if (!proxy.hasOwnProperty("prop"))
+                throw Error("FAIL: hasOwnProperty");
+
+            return "SUCCESS";
+        })()
+    )SNIPPET");
+
+    QJSEngine engine;
+    QJSValue value = engine.evaluate(expression);
+    QVERIFY(value.isString() && value.toString() == QStringLiteral("SUCCESS"));
+}
+
 QTEST_MAIN(tst_qqmlecmascript)
 
 #include "tst_qqmlecmascript.moc"
diff --git a/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml
new file mode 100644
index 0000000000..87cac10200
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml
@@ -0,0 +1,11 @@
+import QtQml 2.15
+
+QtObject {
+    component IC : QtObject {
+        property string name
+        property int age
+    }
+
+    property IC other: IC { name: "Toby"; age: 30 }
+    property list<IC> listProp: [IC { name: "Alfred Ill"; age: 65 }, IC { name: "Claire Zachanassian"; age: 62}]
+}
diff --git a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
index 8adcbc1837..e247a139ec 100644
--- a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
+++ b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
@@ -5604,6 +5604,7 @@ void tst_qqmllanguage::inlineComponent_data()
     QTest::newRow("Alias resolves correctly") << testFileUrl("inlineComponentWithAlias.qml") << QColorConstants::Svg::lime << 42 << true;
 
     QTest::newRow("Two inline components in same do not crash (QTBUG-86989)") << testFileUrl("twoInlineComponents.qml") << QColor() << 0 << false;
+    QTest::newRow("Inline components used in same file (QTBUG-89173)") << testFileUrl("inlineComponentsSameFile.qml") << QColor() << 0 << false;
 }
 
 void tst_qqmllanguage::inlineComponentReferenceCycle_data()
diff --git a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
index d54e3467b7..1953798a15 100644
--- a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
+++ b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
@@ -130,6 +130,7 @@ private slots:
     void dynamic_roles_crash_QTBUG_38907();
     void nestedListModelIteration();
     void undefinedAppendShouldCauseError();
+    void nullPropertyCrash();
 };
 
 bool tst_qqmllistmodel::compareVariantList(const QVariantList &testList, QVariant object)
@@ -1723,6 +1724,27 @@ void tst_qqmllistmodel::undefinedAppendShouldCauseError()
     QScopedPointer<QObject>(component.create());
 }
 
+// QTBUG-89173
+void tst_qqmllistmodel::nullPropertyCrash()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.setData(
+            R"(import QtQuick 2.15
+            ListView {
+                model: ListModel { id: listModel }
+
+                delegate: Item {}
+
+                Component.onCompleted: {
+                    listModel.append({"a": "value1", "b":[{"c":"value2"}]})
+                    listModel.append({"a": "value2", "b":[{"c":null}]})
+                }
+            })",
+            QUrl());
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: c is null. Adding an object with a null member does not create a role for it.");
+    QScopedPointer<QObject>(component.create());
+}
 
 QTEST_MAIN(tst_qqmllistmodel)
 
diff --git a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
index 54f73c6e0c..d489a873e4 100644
--- a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
+++ b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
@@ -176,6 +176,7 @@ private slots:
     void checkSyncView_connect_late_data();
     void checkSyncView_connect_late();
     void checkSyncView_pageFlicking();
+    void checkSyncView_emptyModel();
     void delegateWithRequiredProperties();
     void checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable();
     void replaceModel();
@@ -2731,6 +2732,48 @@ void tst_QQuickTableView::checkSyncView_pageFlicking()
     QVERIFY(tableViewPrivate->scheduledRebuildOptions & QQuickTableViewPrivate::RebuildOption::CalculateNewTopLeftRow);
 }
 
+void tst_QQuickTableView::checkSyncView_emptyModel()
+{
+    // When a tableview has a syncview with an empty model then it should still be
+    // showing the tableview without depending on the syncview. This is particularly
+    // important for headerviews for example
+    LOAD_TABLEVIEW("syncviewsimple.qml");
+    GET_QML_TABLEVIEW(tableViewH);
+    GET_QML_TABLEVIEW(tableViewV);
+    GET_QML_TABLEVIEW(tableViewHV);
+    QQuickTableView *views[] = {tableViewH, tableViewV, tableViewHV};
+
+    auto model = TestModelAsVariant(100, 100);
+
+    for (auto view : views)
+        view->setModel(model);
+
+    WAIT_UNTIL_POLISHED_ARG(tableViewHV);
+
+    // Check that geometry properties are mirrored
+    QCOMPARE(tableViewH->columnSpacing(), tableView->columnSpacing());
+    QCOMPARE(tableViewH->rowSpacing(), 0);
+    QCOMPARE(tableViewH->contentWidth(), tableView->contentWidth());
+    QVERIFY(tableViewH->contentHeight() > 0);
+    QCOMPARE(tableViewV->columnSpacing(), 0);
+    QCOMPARE(tableViewV->rowSpacing(), tableView->rowSpacing());
+    QCOMPARE(tableViewV->contentHeight(), tableView->contentHeight());
+    QVERIFY(tableViewV->contentWidth() > 0);
+
+    QCOMPARE(tableViewH->contentX(), tableView->contentX());
+    QCOMPARE(tableViewH->contentY(), 0);
+    QCOMPARE(tableViewV->contentX(), 0);
+    QCOMPARE(tableViewV->contentY(), tableView->contentY());
+    QCOMPARE(tableViewHV->contentX(), tableView->contentX());
+    QCOMPARE(tableViewHV->contentY(), tableView->contentY());
+
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.left(), tableViewPrivate->loadedTableOuterRect.left());
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.top(), 0);
+
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.top(), tableViewPrivate->loadedTableOuterRect.top());
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.left(), 0);
+}
+
 void tst_QQuickTableView::checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable()
 {
     LOAD_TABLEVIEW("plaintableview.qml");
diff --git a/tests/auto/quick/qquicktext/tst_qquicktext.cpp b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
index 42fdbea58d..308c6b5091 100644
--- a/tests/auto/quick/qquicktext/tst_qquicktext.cpp
+++ b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
@@ -2243,6 +2243,43 @@ void tst_qquicktext::lineCount()
     QCOMPARE(myText->lineCount(), 2);
     QCOMPARE(myText->truncated(), true);
     QCOMPARE(myText->maximumLineCount(), 2);
+
+    // QTBUG-84458
+    myText->resetMaximumLineCount();
+    myText->setText("qqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 2);
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::HorizontalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::VerticalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::Fit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    QScopedPointer<QQuickView> layoutWindow(createView(testFile("lineLayoutHAlign.qml")));
+    QQuickText *lineLaidOut = layoutWindow->rootObject()->findChild<QQuickText*>("myText");
+    QVERIFY(lineLaidOut != nullptr);
+
+    lineLaidOut->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(lineLaidOut->lineCount(), 3);
+    lineLaidOut->setFontSizeMode(QQuickText::FixedSize);
+    lineLaidOut->setText("");
+    QCOMPARE(lineLaidOut->lineCount(), 1);
 }
 
 void tst_qquicktext::lineHeight()
diff --git a/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml
new file mode 100644
index 0000000000..ff10eba23d
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml
@@ -0,0 +1,30 @@
+import QtQml 2.12
+import QtQml.Models 2.12
+import QtQuick 2.12
+
+Item {
+    height: 480
+    width: 320
+    Rectangle {
+        id: rootRect
+
+        function addItem(desc) {
+            myModel.append({"desc": desc});
+        }
+
+        Rectangle {
+            ListView {
+                objectName: "listView"
+                delegate: Text {
+                    required property string desc
+                    text: desc
+                }
+                model: ListModel { id: myModel }
+            }
+        }
+
+        Component.onCompleted: {
+            addItem("Test creation of a delegate with a property");
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickview_extra/qquickview_extra.pro b/tests/auto/quick/qquickview_extra/qquickview_extra.pro
new file mode 100644
index 0000000000..b40af0ce19
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/qquickview_extra.pro
@@ -0,0 +1,12 @@
+CONFIG += testcase
+TARGET = tst_qquickview_extra
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qquickview_extra.cpp
+
+include (../../shared/util.pri)
+include (../shared/util.pri)
+
+TESTDATA = data/*
+
+QT += core-private gui-private qml-private quick-private testlib
diff --git a/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp
new file mode 100644
index 0000000000..f697a438bd
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtest.h>
+#include <QtTest/QSignalSpy>
+#include <QtQuick/qquickview.h>
+#include <QtQuick/qquickitem.h>
+#include <QtQml/qqmlengine.h>
+#include "../../shared/util.h"
+#include <QtCore/QDebug>
+#include <QtCore/QTimer>
+
+// Extra app-less tests
+class tst_QQuickViewExtra : public QQmlDataTest
+{
+    Q_OBJECT
+public:
+    tst_QQuickViewExtra();
+
+private slots:
+    void qtbug_87228();
+};
+
+tst_QQuickViewExtra::tst_QQuickViewExtra() { }
+
+void tst_QQuickViewExtra::qtbug_87228()
+{
+    QScopedPointer<QSignalSpy> deletionSpy;
+    {
+        int argc = 0;
+        QGuiApplication app(argc, nullptr);
+        QQuickView view;
+
+        view.setSource(testFileUrl("qtbug_87228.qml"));
+        view.show();
+        QTimer::singleShot(500, &app, QCoreApplication::quit);
+        app.exec();
+
+        QObject *listView = view.findChild<QObject *>("listView");
+        QVERIFY(listView);
+        QQuickItem *contentItem = listView->property("contentItem").value<QQuickItem *>();
+        QVERIFY(contentItem);
+        auto children = contentItem->childItems();
+        QVERIFY(children.size() > 0);
+        // for the sake of this test, any child would be suitable, so pick first
+        deletionSpy.reset(new QSignalSpy(children[0], SIGNAL(destroyed(QObject *))));
+    }
+    QCOMPARE(deletionSpy->count(), 1);
+}
+
+QTEST_APPLESS_MAIN(tst_QQuickViewExtra)
+
+#include "tst_qquickview_extra.moc"
diff --git a/tests/auto/quick/quick.pro b/tests/auto/quick/quick.pro
index 541bfdd527..45bcf8a9ce 100644
--- a/tests/auto/quick/quick.pro
+++ b/tests/auto/quick/quick.pro
@@ -85,6 +85,7 @@ QUICKTESTS += \
     qquicktextinput \
     qquickvisualdatamodel \
     qquickview \
+    qquickview_extra \
     qquickcanvasitem \
     qquickdesignersupport \
     qquickscreen \
diff --git a/tools/qmltime/qmltime.pro b/tools/qmltime/qmltime.pro
index c915f6e8c1..366d90f75b 100644
--- a/tools/qmltime/qmltime.pro
+++ b/tools/qmltime/qmltime.pro
@@ -1,4 +1,3 @@
-TEMPLATE = app
 TARGET = qmltime
 QT += qml quick
 QT += quick-private
@@ -12,3 +11,5 @@ QMAKE_TARGET_DESCRIPTION = QML Time
 
 SOURCES += qmltime.cpp
 HEADERS += qmltime.h
+
+load(qt_tool)
